<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sqlalchemy on Library</title>
    <link>https://dragon-library.github.io/docs/library/tags/sqlalchemy/</link>
    <description>Recent content in sqlalchemy on Library</description>
    <generator>Source Themes academia (https://sourcethemes.com/academic/)</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 02 Jun 2020 00:00:00 +0000</lastBuildDate>
    
	    <atom:link href="https://dragon-library.github.io/docs/library/tags/sqlalchemy/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>การอ่านเขียนข้อมูลจากฐานข้อมูล sql</title>
      <link>https://dragon-library.github.io/docs/library/post/python/tutorials/read-write-database-sql/</link>
      <pubDate>Tue, 02 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dragon-library.github.io/docs/library/post/python/tutorials/read-write-database-sql/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;เขียนเมื่อ 2020/06/02 19:13&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ฐานข้อมูล sql เป็นรูปแบบการเก็บข้อมูลที่ใช้กันอย่างกว้างขวาง การเก็บข้อมูลของ sql นั้นมีลักษณะเป็นตารางข้อมูลเป็นแถวๆ คล้ายกับ pandas&lt;/p&gt;

&lt;p&gt;pandas มีคำสั่งที่ช่วยให้ติดต่อกับฐานข้อมูล sql ได้อย่างง่ายดายขึ้น โดยสามารถเอาตารางจาก pandas เขียนลงใน sql และอ่านตารางจาก sql เข้ามาเป็นตารางใน pandas  ความสามารถส่วนใหญ่ในส่วนนี้จะใช้กับมอดูล sqlalchemy เป็นหลัก ดังนั้นจำเป็นต้องติดตั้งมอดูล sqlalchemy ด้วย&lt;/p&gt;

&lt;p&gt;เกี่ยวกับการใช้ sqlalchemy อ่านได้ใน  &lt;a href=&#34;https://phyblas.hinaboshi.com/20200529&#34; target=&#34;_blank&#34;&gt;https://phyblas.hinaboshi.com/20200529&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;เพียงแต่ว่าก็อาจไม่ต้องเรียกใช้ sqlalchemy โดยตรง แค่มีลงมอดูล sqlalchamy ไว้ก็สามารถใช้ความสามารถนี้ได้แล้ว&lt;/p&gt;

&lt;p&gt;ฐานข้อมูล sql ยังแบ่งออกเป็นหลายแบบ เช่น sqlite, posgresql, mysql ซึ่ง sqlalchemy ก็รองรับฐานข้อมูลหลายชนิด ซึ่งก็ทำให้ใช้ใน pandas ได้ด้วยเช่นกัน ในที่นี้จะใช้ sqlite ซึ่งเป็นฐานข้อมูล sql แบบที่ง่ายที่สุด มีติดตัวอยู่ตั้งแต่แรกไม่ต้องติดตั้งเพิ่ม  เมื่อมีตารางข้อมูลเก็บอยู่ในเดตาเฟรมแล้วต้องการบันทึกลงฐานข้อมูล sql สามารถทำได้โดยใช้เมธอด .to_sql() จากตัวเดตาเฟรมนั้น&lt;/p&gt;

&lt;p&gt;การใช้คำสั่งนี้มีการเขียนอยู่หลายวิธี ที่ง่ายที่สุดก็คือใส่ชื่อตารางและตามด้วยชื่อตารางที่เก็บข้อมูลนั้นอยู่  วิธีที่ง่ายที่สุดคือแค่ใส่ชื่อตาราง แล้วตามด้วยชื่อตัวฐานข้อมูลที่จะเก็บตารางข้อมูลนั้นไว้&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;df.to_sql(ชื่อตาราง,ชื่อฐานข้อมูล)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ตัวอย่างการใช้&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pandas as pd

p = {&#39;สายพันธุ์&#39;:[&#39;ซันกูส&#39;,&#39;ฮาบุเนก&#39;,&#39;ลูนาโทน&#39;],
     &#39;ส่วนสูง&#39;:[1.3,2.7,1],
     &#39;น้ำหนัก&#39;:[40.3,52.5,168]}
pokedf = pd.DataFrame(p,index=[335,336,337])
pokedf.to_sql(&#39;pokemon&#39;,&#39;sqlite:///pkdata.db&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ในที่นี้ใช้กับฐานข้อมูล sqlite ในส่วนของชื่อฐานข้อมูลจะเขียนเป็น  &lt;code&gt;&#39;sqlite:///ชื่อไฟล์&#39;&lt;/code&gt;  แบบนี้  อนึ่ง เดิมทีแล้ว .to_sql() ควรจะใช้กับตัวออบเจ็กต์เชื่อมต่อ ซึ่งใน sqlalchemy เรียกว่า engine  หากเขียนแบบเต็มๆตั้งแต่ขั้นตอนการสร้าง engine ก็อาจเขียนแบบนี้&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sqlalchemy

engine = sqlalchemy.create_engine(&#39;sqlite:///pkdata.db&#39;)
pokedf.to_sql(&#39;pokemon&#39;,engine)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;เพียงแต่ว่าสามารถเขียนย่อเป็นแบบใส่แค่ชื่อฐานข้อมูลไปโดยตรงก็ได้ ดังนั้นจึงสะดวกกว่ามาก ไม่จำเป็นต้อง import sqlalchemy มาโดยตรงเลยด้วย  ส่วนการอ่านข้อมูลจากตารางใน sql ทำได้โดยฟังก์ชัน pd.read_sql_table() วิธีใช้ก็เช่นเดียวกับตอนเขียนข้อมูลลง sql นั่นคือใส่ชื่อตารางกับชื่อฐานข้อมูล&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;df = pd.read_sql_table(ชื่อตาราง,ชื่อฐานข้อมูล)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ตัวอย่างเช่นถ้าต้องการอ่านข้อมูลที่บันทึกลงไปในฐานข้อมูลในตัวอย่างที่แล้ว&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;df = pd.read_sql_table(&#39;pokemon&#39;,&#39;sqlite:///pkdata.db&#39;)
print(df)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;index	สายพันธุ์	ส่วนสูง	น้ำหนัก
0	335	ซันกูส	1.3	40.3
1	336	ฮาบุเนก	2.7	52.5
2	337	ลูนาโทน	1.0	168.0  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;จากในตัวอย่างที่แล้วทั้งตอนเขียนและอ่านล้วนไม่ได้ใส่ตัวเลือกเสริมอะไรลงไปเลย ทุกอย่างจึงเป็นไปตามค่าตั้งต้น&lt;/p&gt;

&lt;p&gt;ซึ่งจะเห็นว่าตอนที่ใช้ .to_sql() นั้นตัวดัชนีก็ถูกเปลี่ยนเป็นคอลัมน์หนึ่งใน sql ไปด้วย โดยชื่อคอลัมน์ดัชนีก็จะกลายเป็นชื่อคอลัมน์ใน sql ด้วย  หากต้องการเปลี่ยนชื่อคอลัมน์ดัชนีใหม่อาจทำได้โดยใส่ในตัวเลือกเสริม index_label เช่น&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;pk = {&#39;สายพันธุ์&#39;:[&#39;โซลร็อก&#39;,&#39;โดจ็อช&#39;],
      &#39;ส่วนสูง&#39;:[1.2,0.4],
      &#39;น้ำหนัก&#39;:[154,1.9]}
index = pd.Series([338,339],name=&#39;หมายเลข&#39;)
pokedf = pd.DataFrame(pk,index=index)
pokedf.to_sql(&#39;pokemon&#39;,&#39;sqlite:///pkdt.db&#39;,index_label=&#39;id&#39;)
print(pd.read_sql_table(&#39;pokemon&#39;,&#39;sqlite:///pkdt.db&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;id	สายพันธุ์	ส่วนสูง	น้ำหนัก
0	338	โซลร็อก	1.2	154.0
1	339	โดจ็อช	0.4	1.9  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;นอกจากนี้ถ้าหากไม่ได้ตั้งชื่อให้คอลัมน์ดัชนี แล้วก็ไม่ได้กำหนด index_label ก็จะถูกตั้งชื่อเป็น index โดยอัตโนมัติ  หากจะให้ทิ้งส่วนดัชนีไปเลยก็ใส่ตัวเลขเสริม index เป็น index=False&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;pk = {&#39;สายพันธุ์&#39;:[&#39;นามาซึน&#39;,&#39;เฮย์งานิ&#39;],
      &#39;ส่วนสูง&#39;:[0.9,0.6],
      &#39;น้ำหนัก&#39;:[23.6,11.5]}
pokedf = pd.DataFrame(pk,index=[340,341])
pokedf.to_sql(&#39;pokemon&#39;,&#39;sqlite:///pkdex.db&#39;,index=False)
print(pd.read_sql_table(&#39;pokemon&#39;,&#39;sqlite:///pkdex.db&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt; สายพันธุ์	ส่วนสูง	น้ำหนัก
0	นามาซึน	0.9	23.6
1	เฮย์งานิ	0.6	11.5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;หากชื่อตารางที่ใส่ไปนั้นซ้ำกับที่มีอยู่ในฐานข้อมูลนั้นแล้ว ปกติจะเกิดข้อผิดพลาดขึ้น&lt;br /&gt;
หากไม่ต้องการให้เป็นเช่นนั้น ก็อาจกำหนดไปในตัวเลือกเสริม if_exists เพิ่มเติม โดยถ้า id_exists=&amp;lsquo;replace&amp;rsquo; ตารางเดิมจะหายไปแล้วเอาข้อมูลใหม่ใส่ลงไปแทน เช่นลองใส่ตารางเดิมซ้ำในฐานข้อมูลเดียวกับตัวอย่างที่แล้ว&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;pk = {&#39;สายพันธุ์&#39;:[&#39;เนนดอล&#39;,&#39;ลีลีลา&#39;],
      &#39;ส่วนสูง&#39;:[1.5,1],
      &#39;น้ำหนัก&#39;:[108,23.8]}
pokedf = pd.DataFrame(pk,index=[344,345])
pokedf.to_sql(&#39;pokemon&#39;,&#39;sqlite:///pkdex.db&#39;,if_exists=&#39;replace&#39;)
print(pd.read_sql_table(&#39;pokemon&#39;,&#39;sqlite:///pkdex.db&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ได้&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;index	สายพันธุ์	ส่วนสูง	น้ำหนัก
0	344	เนนดอล	1.5	108.0
1	345	ลีลีลา	1.0	23.8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;จะเห็นว่าข้อมูลเก่าหายไปแล้วกลายเป็นข้อมูลใหม่  ตรงนี้ถ้าไม่ได้ใส่ หรือใส่ if_exists=&amp;lsquo;fail&amp;rsquo; ก็จะขึ้นมาว่า&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;ValueError: Table &#39;pokemon&#39; already exists.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;นอกจากนี้ ถ้า id_exists=&amp;lsquo;append&amp;rsquo; จะเป็นการเพิ่มข้อมูลเข้าไปในตารางที่มีอยู่แล้ว   เช่น ลองใส่ตารางเดิมซ้ำในฐานข้อมูลเดียวกับตัวอย่างที่แล้ว&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;pk = {&#39;สายพันธุ์&#39;:[&#39;ชิซาริเกอร์&#39;,&#39;ยาจิลอน&#39;],
      &#39;ส่วนสูง&#39;:[1.1,0.5]}
pokedf = pd.DataFrame(pk,index=[342,343])
pokedf.to_sql(&#39;pokemon&#39;,&#39;sqlite:///pkdex.db&#39;,if_exists=&#39;append&#39;)
print(pd.read_sql_table(&#39;pokemon&#39;,&#39;sqlite:///pkdex.db&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ได้&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;index	สายพันธุ์	ส่วนสูง	น้ำหนัก
0	344	เนนดอล	1.5	108.0
1	345	ลีลีลา	1.0	23.8
2	342	ชิซาริเกอร์	1.1	NaN
3	343	ยาจิลอน	0.5	NaN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ข้อมูลที่ใส่ต่อเข้าไปนั้นควรจะมีคอลัมน์ซ้ำกับตารางเดิม หรือจะขาดไปบางคอลัมน์ก็ได้ ค่าที่ขาดจะว่างไว้ แต่ถ้าหากมีคอลัมน์ที่ไม่มีอยู่เดิมก็จะเกิดข้อผิดพลาด  สำหรับชนิดของข้อมูลนั้น ถ้าไม่ได้กำหนดอะไรก็จะเป็นไปตามชนิดของข้อมูลที่สัมพันธ์กับที่อยู่ในเดตาเฟรม  เช่น ตัวอย่างนี้ เมื่อไม่ได้กำหนด dtype ก็จะเป็นแบบนี้&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;pk = {&#39;สายพันธุ์&#39;:[&#39;มิโลคารอส&#39;,&#39;คาคุเรออน&#39;],
      &#39;ส่วนสูง&#39;:[6.2,1],
      &#39;น้ำหนัก&#39;:[162.0,22.0]}
pokedf = pd.DataFrame(pk,pd.Series([350,352],name=&#39;เลข&#39;))

pokedf.to_sql(&#39;pokemon&#39;,&#39;sqlite:///pkdex.db&#39;,if_exists=&#39;replace&#39;)
df = pd.read_sql_table(&#39;pokemon&#39;,&#39;sqlite:///pkdex.db&#39;,coerce_float=False)
print(df.values)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ได้&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[[350 &#39;มิโลคารอส&#39; 6.2 162.0]
 [352 &#39;คาคุเรออน&#39; 1.0 22.0]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;แต่หากต้องการให้เปลี่ยนชนิดข้อมูลเป็นแบบที่ต้องการก็สามารถกำหนดได้โดยตัวเลือกเสริม dtype  การใส่ชนิดข้อมูลนั้นให้ใส่ในรูปของชนิดข้อมูล sqlalchemy (ต้อง import มาใช้)  จากตัวอย่างที่แล้ว ลองกำหนด dtype เข้าไปได้ดังนี้&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sqlalchemy

dtype = {&#39;ส่วนสูง&#39;:sqlalchemy.String,
         &#39;น้ำหนัก&#39;:sqlalchemy.Integer,
         &#39;เลข&#39;:sqlalchemy.Float}

pokedf.to_sql(&#39;pokemon&#39;,&#39;sqlite:///pkdex.db&#39;,if_exists=&#39;replace&#39;,dtype=dtype)
df = pd.read_sql_table(&#39;pokemon&#39;,&#39;sqlite:///pkdex.db&#39;)
print(df.values)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ได้&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[[350.0 &#39;มิโลคารอส&#39; &#39;6.2&#39; 162]
 [352.0 &#39;คาคุเรออน&#39; &#39;1.0&#39; 22]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;เวลาอ่านข้อมูลจาก sql ด้วย pd.read_sql_table() ก็มีตัวเลือกเสริมมากมายเพื่ออำนวยความสะดวกในการการกำหนดลักษณะการอ่าน  เช่น index_col ใช้กำหนดคอลัมน์ที่จะเป็นดัชนี ถ้าหากไม่กำหนดอะไรไปก็จะไม่มีคอลัมน์ไหนกลายเป็นดัชนี แล้วเป็นตัวเลข 0,1,2 ไป&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;pk = {&#39;สายพันธุ์&#39;:[&#39;ฮินบาส&#39;,&#39;โปวาเลิน&#39;,&#39;คาเงะโบวซึ&#39;],
      &#39;ส่วนสูง&#39;:[0.6,0.3,0.6],
      &#39;น้ำหนัก&#39;:[7.4,0.8,2.3]}
pokedf = pd.DataFrame(pk,pd.Series([349,351,353],name=&#39;เลข&#39;))
pokedf.to_sql(&#39;pokemon&#39;,&#39;sqlite:///pkdex.db&#39;,if_exists=&#39;replace&#39;)

print(pd.read_sql_table(&#39;pokemon&#39;,&#39;sqlite:///pkdex.db&#39;))
print(pd.read_sql_table(&#39;pokemon&#39;,&#39;sqlite:///pkdex.db&#39;,index_col=&#39;เลข&#39;))
print(pd.read_sql_table(&#39;pokemon&#39;,&#39;sqlite:///pkdex.db&#39;,index_col=&#39;สายพันธุ์&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ได้&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; เลข	สายพันธุ์	ส่วนสูง	น้ำหนัก
0	349	ฮินบาส	0.6	7.4
1	351	โปวาเลิน	0.3	0.8
2	353	คาเงะโบวซึ	0.6	2.3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt; สายพันธุ์	ส่วนสูง น้ำหนัก เลข	 	 	 
349	ฮินบาส	0.6	7.4
351	โปวาเลิน	0.3	0.8
353	คาเงะโบวซึ	0.6	2.3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
 	 เลข	ส่วนสูง	น้ำหนัก
สายพันธุ์	 	 	 
ฮินบาส	349	0.6	7.4
โปวาเลิน	351	0.3	0.8
คาเงะโบวซึ	353	0.6	2.3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ส่วนการเลือกเอาข้อมูลเฉพาะแค่บางคอลัมน์ทำได้โดยใส่ตัวเลือกเสริม columns&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;pk = {&#39;สายพันธุ์&#39;:[&#39;ยูเรเดิล&#39;,&#39;อาโนปธ์&#39;,&#39;อาร์มัลโด&#39;],
      &#39;ส่วนสูง&#39;:[1.5,0.7,1.5],
      &#39;น้ำหนัก&#39;:[60.4,12.5,68.2]}
pokedf = pd.DataFrame(pk,index=[346,347,348])
pokedf.to_sql(&#39;pokemon&#39;,&#39;sqlite:///pkdex.db&#39;,if_exists=&#39;replace&#39;)

print(pd.read_sql_table(&#39;pokemon&#39;,&#39;sqlite:///pkdex.db&#39;,columns=[&#39;index&#39;,&#39;สายพันธุ์&#39;]))
print(pd.read_sql_table(&#39;pokemon&#39;,&#39;sqlite:///pkdex.db&#39;,columns=[&#39;index&#39;,&#39;สายพันธุ์&#39;],index_col=&#39;index&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ได้&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 	index	สายพันธุ์
0	346	ยูเรเดิล
1	347	อาโนปธ์
2	348	อาร์มัลโด
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;	 	สายพันธุ์
index	 
346		ยูเรเดิล
347		อาโนปธ์
348		อาร์มัลโดแต่ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pd.read_sql_table() นั้นไม่สามารถกำหนดเงื่อนไขให้ข้อมูลออกมาเฉพาะบางแถวได้ จะอ่านข้อมูลออกมาทุกแถวเสมอ (เหมือนการใส่ where ในโค้ด sql)&lt;/p&gt;

&lt;p&gt;ฟังก์ชันอีกตัวที่ใช้สำหรับอ่านข้อมูลคือ pd.read_sql_query() ซึ่งใช้เขียนโค้ด sql เพื่อสั่งอ่านข้อมูลเข้ามาโดยตรง  การจะใช้ฟังก์ชันนี้ได้จึงต้องรู้โค้ด sql ด้วยทำให้อาจใช้ยากกว่า แต่ข้อดีคือเขียนได้ยืดหยุ่นกว่า สามารถเขียน where เพื่อกำหนดเงื่อนไขได้ หรือเขียน order by เพื่อเรียงลำดับข้อมูลได้  การกำหนดคอลัมน์ที่จะใช้เป็นดัชนีก็ทำได้ด้วยการใส่ index_col เช่นกัน&lt;/p&gt;

&lt;p&gt;ตัวอย่าง&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;pk = {&#39;สายพันธุ์&#39;:[&#39;จูเพ็ตตา&#39;,&#39;โยมาวารุ&#39;,&#39;ซามาโยวรุ&#39;,&#39;โทรปิอุส&#39;],
      &#39;ส่วนสูง&#39;:[1.1,0.8,1.6,2],
      &#39;น้ำหนัก&#39;:[12.5,35,30.6,100]}
pokedf = pd.DataFrame(pk,index=[354,355,356,357])
pokedf.to_sql(&#39;pokemon&#39;,&#39;sqlite:///pkdex.db&#39;,if_exists=&#39;replace&#39;)

sql = &#39;select * from pokemon where น้ำหนัก&amp;gt;32&#39;
print(pd.read_sql_query(sql,&#39;sqlite:///pkdex.db&#39;))
sql = &#39;select สายพันธุ์,น้ำหนัก from pokemon order by น้ำหนัก desc&#39;
print(pd.read_sql_query(sql,&#39;sqlite:///pkdex.db&#39;))
sql = &#39;select * from pokemon&#39;
print(pd.read_sql_query(sql,&#39;sqlite:///pkdex.db&#39;,index_col=&#39;index&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ได้&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 	index	สายพันธุ์	ส่วนสูง	น้ำหนัก
0	355	โยมาวารุ	0.8	35.0
1	357	โทรปิอุส	2.0	100.0
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;  	สายพันธุ์	น้ำหนัก
0	โทรปิอุส	100.0
1	โยมาวารุ	35.0
2	ซามาโยวรุ	30.6
3	จูเพ็ตตา	12.5 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
 	สายพันธุ์	ส่วนสูง	น้ำหนัก
index	 	 	 
354	จูเพ็ตตา	1.1	12.5
355	โยมาวารุ	0.8	35.0
356	ซามาโยวรุ	1.6	30.6
357	โทรปิอุส	2.0	100.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;หากใน โค้ดมีการใช้เครื่องหมายคำถาม ? ซึ่งแทนตัวพารามิเตอร์ สามารถใส่ค่าลงไปได้โดยเติมลิสต์ของพารามิเตอร์ที่ต้องการแทนใส่ในคีย์เวิร์ด params เช่น&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;pk = {&#39;สายพันธุ์&#39;:[&#39;ชิรีน&#39;,&#39;อับโซล&#39;,&#39;โซนาโน&#39;],
      &#39;ส่วนสูง&#39;:[0.6,1.2,0.6],
      &#39;น้ำหนัก&#39;:[1,47,14]}
pokedf = pd.DataFrame(pk,pd.Series([358,359,360],name=&#39;เลข&#39;))
pokedf.to_sql(&#39;pokemon&#39;,&#39;sqlite:///pkdex.db&#39;,if_exists=&#39;replace&#39;)

sql = &#39;select * from pokemon where สายพันธุ์==?&#39;
print(pd.read_sql_query(sql,&#39;sqlite:///pkdex.db&#39;,params=[&#39;ชิรีน&#39;]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ได้&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;		 เลข	สายพันธุ์	ส่วนสูง	น้ำหนัก
0		358		ชิรีน		0.6	1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;หรือใส่ในรูปของตัวแปรที่ชื่อขึ้นต้นด้วยโคลอน : ก็ได้ กรณีนี้ให้ใส่ params เป็นดิกชันนารี เช่น&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sql = &#39;select * from pokemon where เลข=:lek&#39;
print(pd.read_sql_query(sql,&#39;sqlite:///pkdex.db&#39;,params={&#39;lek&#39;: 359}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ได้&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 	เลข	สายพันธุ์	ส่วนสูง	น้ำหนัก
0	359	อับโซล	1.2		47
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;นอกจากนี้มีฟังก์ชัน &lt;code&gt;pd.read_sql()&lt;/code&gt; ซึ่งอาจใช้เพื่อแทน &lt;code&gt;pd.read_sql_table()&lt;/code&gt; หรือ &lt;code&gt;pd.read_sql_query()&lt;/code&gt; ได้&lt;/p&gt;

&lt;p&gt;โดย &lt;code&gt;pd.read_sql()&lt;/code&gt; จะดูจากค่าที่ใส่ไปเองว่าควรจะเรียก &lt;code&gt;pd.read_sql_table()&lt;/code&gt; หรือ pd.read_sql_query() ดังนั้นในทางปฏิบัติแล้วถ้าไม่อยากเขียนยาวจะใช้&lt;code&gt;pd.read_sql()&lt;/code&gt;อย่างเดียวตลอดก็ได้&lt;/p&gt;

&lt;p&gt;ตัวอย่าง&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;pk = {&#39;สายพันธุ์&#39;:[&#39;ยุกิวาราชิ&#39;,&#39;โอนิโกริ&#39;,&#39;ทามะซาราชิ&#39;],
      &#39;ส่วนสูง&#39;:[0.7,1.5,0.8],
      &#39;น้ำหนัก&#39;:[16.8,256.5,39.5]}
pokedf = pd.DataFrame(pk,pd.Series([361,362,363],name=&#39;เลข&#39;))
pokedf.to_sql(&#39;pokemon&#39;,&#39;sqlite:///pkdex.db&#39;,if_exists=&#39;replace&#39;)

print(pd.read_sql(&#39;pokemon&#39;,&#39;sqlite:///pkdex.db&#39;,columns=[&#39;เลข&#39;,&#39;สายพันธุ์&#39;]))
sql = &#39;select * from pokemon where น้ำหนัก&amp;lt;40&#39;

print(pd.read_sql(sql,&#39;sqlite:///pkdex.db&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ได้&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 	เลข	สายพันธุ์
0	361	ยุกิวาราชิ
1	362	โอนิโกริ
2	363	ทามะซาราชิ

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt; 	เลข	สายพันธุ์		ส่วนสูง	น้ำหนัก
0	361	ยุกิวาราชิ		0.7		16.8
1	363	ทามะซาราชิ	0.8		39.5

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;เช่นเดียวกับ .to_sql() ฟังก์ชัน pd.read_sql_table(), pd.read_sql_query() และ pd.read_sql() เองก็เดิมทีควรใช้กับ engine ของ sqlalchemy เช่นกัน การเขียนแบบตัวอย่างที่ยกมาจึงเป็นแค่การเขียนย่อ&lt;/p&gt;

&lt;p&gt;หากเขียนเต็มๆตั้งแต่สร้าง engine ของ sqlalchemy ก็อาจเขียนได้แบบนี้&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sqlalchemy

engine = sqlalchemy.create_engine(&#39;sqlite:///pkdex.db&#39;)
print(pd.read_sql(&#39;pokemon&#39;,engine))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;นอกจากนี้ pd.read_sql_query() หรือ pd.read_sql() สามารถใช้กับมอดูล sqlite3 ได้ด้วย ดังนั้นจึงอาจเขียนแบบนี้&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sqlite3

conn = sqlite3.connect(&#39;pkdex.db&#39;)
print(pd.read_sql(&#39;select * from pokemon&#39;,conn))
conn.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;เพียงแต่ .to_sql() กับ df.read_sql_table จะใช้ได้กับ sqlalchemy เท่านั้น ใช้กับ sqlite3 ไม่ได้&lt;/p&gt;

&lt;p&gt;อ้างอิง&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_sql.html&#34; target=&#34;_blank&#34;&gt;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_sql.html&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_sql_table.html&#34; target=&#34;_blank&#34;&gt;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_sql_table.html&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_sql_query.html&#34; target=&#34;_blank&#34;&gt;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_sql_query.html&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_sql.html&#34; target=&#34;_blank&#34;&gt;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_sql.html&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.cjavapy.com/article/143&#34; target=&#34;_blank&#34;&gt;https://www.cjavapy.com/article/143&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://qiita.com/orengeo/items/36e8809e07be7c1b145e&#34; target=&#34;_blank&#34;&gt;https://qiita.com/orengeo/items/36e8809e07be7c1b145e&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Reference : &lt;a href=&#34;https://phyblas.hinaboshi.com/yancham20&#34; target=&#34;_blank&#34;&gt;https://phyblas.hinaboshi.com/yancham20&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>จัดการฐานข้อมูล SQL ด้วย sqlalchemy</title>
      <link>https://dragon-library.github.io/docs/library/post/python/tutorials/manage-sql-sqlalchemy/</link>
      <pubDate>Sun, 31 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dragon-library.github.io/docs/library/post/python/tutorials/manage-sql-sqlalchemy/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;featured.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;สารบัญ&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;๛ แนวคิดการควบคุมฐานข้อมูลในรูปออบเจ็กต์&lt;br /&gt;
๛ การติดตั้ง&lt;br /&gt;
๛ การเริ่มต้นเชื่อมต่อกับฐานข้อมูลเพื่อเตรียมการใช้งาน&lt;br /&gt;
๛ การสร้างคลาสตารางข้อมูล&lt;br /&gt;
๛ การเตรียมไฟล์แบบจำลองและตัวสร้างเซสชัน&lt;br /&gt;
๛ การเพิ่มข้อมูลลงไป&lt;br /&gt;
๛ การอ่านข้อมูลในตาราง (query)&lt;br /&gt;
๛ การอ่านข้อมูลทั้งหมดใส่ลิสต์ (all)&lt;br /&gt;
๛ การกำหนดวิธีการเรียงลำดับข้อมูล (order_by)&lt;br /&gt;
๛ การเอาข้อมูลเฉพาะตัวแรกตัวเดียว (first)&lt;br /&gt;
๛ การจำกัดเอาข้อมูลเฉพาะบางส่วน (limit และ offset)&lt;br /&gt;
๛ การกำหนดเงื่อนไขข้อมูลที่จะอ่าน (filter)&lt;br /&gt;
๛ การแก้ข้อมูล (update)&lt;br /&gt;
๛ การลบข้อมูลออก (delete)&lt;br /&gt;
๛ การย้อนคืนสิ่งที่ทำกลับไป (rollback)&lt;br /&gt;
๛ การป้อนคำสั่ง SQL ใส่โดยตรง (execute)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;sqlalchemy&lt;/strong&gt; เป็นมอดูลในไพธอนที่ใช้สำหรับเชื่อมต่อกับระบบจัดการฐานข้อมูล SQL โดยควบคุมฐานข้อมูลในรูปแบบที่สั่งข้อมูลเหมือนเป็นออบเจ็กต์ตามแนวคิดเชิงวัตถุ&lt;/p&gt;

&lt;p&gt;บทความนี้จะอธิบายแนวคิดเบื้องต้นและวิธีการใช้ sqlalchemy เพื่อจัดการกับฐานข้อมูลอย่างง่าย&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;แนวคิดการควบคุมฐานข้อมูลในรูปออบเจ็กต์介&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ปกติการเชื่อมต่อกับฐานข้อมูล SQL จะทำโดยใช้โค้ดคำสั่งภาษา SQL แม้ว่าบางทีอาจไม่ได้สั่งโดยตรงแต่ผ่านตัวกลางอะไรก็ตาม&lt;/p&gt;

&lt;p&gt;ไพธอนมีมอดูลมาตรฐานที่ใช้จัดการฐานข้อมูลอยู่แล้วคือ sqlite3 อย่างไรก็ตาม มอดูลนี้เป็นแค่ตัวกลางสำหรับส่งโค้ดคำสั่ง SQL เข้าไปสั่งฐานข้อมูลเท่านั้น เรายังคงต้องเขียนโค้ดควบคุมด้วยตัวเอง&lt;/p&gt;

&lt;p&gt;เกี่ยวกับการใช้ sqlite3 ได้เขียนถึงไปใน &amp;gt;&amp;gt; &lt;a href=&#34;https://phyblas.hinaboshi.com/20200519&#34; target=&#34;_blank&#34;&gt;https://phyblas.hinaboshi.com/20200519&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;แต่หากใช้ sqlalchemy แม้จะใช้ควบคุมฐานข้อมูล SQL เหมือนกัน แต่ใช้วิธีการต่างกัน คือ sqlalchemy จะเป็นการควบคุมทางอ้อม เรามักจะไม่ต้องพิมพ์โค้ดคำสั่ง SQL เองโดยตรง&lt;/p&gt;

&lt;p&gt;วิธีการของ sqlalchemy คือมองว่าตารางข้อมูลในฐานข้อมูลนั้นเป็นออบเจ็กต์ตัวหนึ่ง โดยออบเจ็กต์นั้นจะมีฟังก์ชันหรือเมธอดต่างๆซึ่งเมื่อใช้แล้วจะไปสร้างโค้ดคำสั่ง SQL สั่งฐานข้อมูลอีกที&lt;/p&gt;

&lt;p&gt;ดังนั้นแล้วการควบคุมออบเจ็กต์นั้นก็เป็นการควบคุมข้อมูลในฐานข้อมูล ถ้าเราต้องการดึงข้อมูลในฐานข้อมูลมาอ่าน sqlalchemy ก็จะไปสร้างคำสั่งดึงข้อมูลมาให้ ถ้าเราทำความเปลี่ยนแปลงอะไรกับออบเจ็กต์ มันก็จะไปเปลี่ยนแปลงตัวข้อมูลในฐานข้อมูลด้วยโดยอัตโนมัติ&lt;/p&gt;

&lt;p&gt;การที่ทำแบบนี้ได้เพราะในตัวมอดูล sqlalchemy นั้นมีการตั้งความเชื่อมโยงระหว่างการกระทำต่อตัวออบเจ็กต์ กับคำสั่ง SQL สำหรับสั่งฐานข้อมูล&lt;/p&gt;

&lt;p&gt;แนวคิดแบบนี้เรียกว่า&lt;strong&gt;การจับคู่เชื่อมโยงระหว่างเชิงวัตถุและเชิงสัมพันธ์ (Object-Relational mapping)&lt;/strong&gt; หรือมักเรียกย่อๆว่า &lt;strong&gt;ORM&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;นอกจาก sqlalchemy แล้วในไพธอนก็ยังมีมอดูลตัวอื่นที่ทำคล้ายๆกันนี้ เช่น &lt;a href=&#34;https://tortoise-orm.readthedocs.io/&#34; target=&#34;_blank&#34;&gt;tortoise-orm&lt;/a&gt; รวมถึง &lt;a href=&#34;https://www.djangoproject.com/&#34; target=&#34;_blank&#34;&gt;django&lt;/a&gt; ซึ่งเป็นมอดูลทำเฟรมเวิร์กเขียนเว็บ ก็มีมอดูลย่อยที่ควบคุมฐานข้อมูลแบบ ORM เช่นเดียวกัน&lt;/p&gt;

&lt;p&gt;sqlalchemy อาจใช้คู่กับมอดูลไพธอนสำหรับเขียนเว็บที่ไม่ได้มี ORM อยู่ในตัวสำเร็จเหมือนอย่างที่ django มีแบบนั้น เช่น flask หรือ responder&lt;/p&gt;

&lt;p&gt;หากเทียบกับในภาษารูบีก็เหมือนกับมอดูล activerecord ซึ่งมักจะใช้คู่กับ ruby on rails เฟรมเวิร์กเขียนเว็บยอดนิยมตัวหนึ่ง&lt;/p&gt;

&lt;p&gt;sqlalchemy อาจใช้ได้กับฐานข้อมูลต่างๆเหล่านี้&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SQLite&lt;/li&gt;
&lt;li&gt;MySQL&lt;/li&gt;
&lt;li&gt;PostgreSQL&lt;/li&gt;
&lt;li&gt;Oracle&lt;/li&gt;
&lt;li&gt;Mycrosoft SQL Server&lt;/li&gt;
&lt;li&gt;Firebird&lt;/li&gt;
&lt;li&gt;Sybase&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ซึ่งฐานข้อมูลแต่ละตัวนั้นก็จะมีลักษณะการเขียนที่ต่างกันออกไป และ sqlalchemy ช่วยรองรับความแตกต่างนี้ให้ได้ในระดับหนึ่ง อย่างไรก็ตามความต่างนี้ก็ส่งผลอยู่บ้าง แต่พวกคำสั่งพื้นฐานจะใช้ได้ไม่ต่างกันนัก&lt;/p&gt;

&lt;p&gt;ในบทความนี้จะใช้ SQLite เป็นตัวอย่าง แต่วิธีการสามารถนำไปใช้กับฐานข้อมูลชนิดอื่นได้เช่นกัน แม้อาจมีรายละเอียดหรือผลลัพธ์ต่างกันออกไปบ้าง&lt;/p&gt;

&lt;p&gt;เมื่อใช้ sqlalchemy แล้วจะทำให้เราอ่านเขียนข้อมูลในฐานข้อมูล SQL ได้โดยไม่ต้องเขียนโค้ดภาษา SQL โดยตรงเลย เพียงแต่ในเบื้องหลังการทำงานของมันจริงๆแล้วก็คือสร้างโค้ด SQL โดยอัตโนมัติเพื่อไปสั่งอีกที ดังนั้นก็ยังควรจะรู้โค้ด SQL อยู่ เมื่อมีปัญหาจะได้เข้าใจว่าเกิดอะไรขึ้น อีกทั้งคำสั่งลึกๆซับซ้อนจำเพาะบางอย่างเขียนโค้ด SQL สั่งเองอาจจะเร็วกว่าด้วย&lt;/p&gt;

&lt;p&gt;ปกติเวลาเกิดข้อผิดพลาดอะไรขึ้นระหว่างติดต่อกับฐานข้อมูลอยู่ sqlalchemy ก็จะแสดงโค้ด SQL ที่ใช้ตอนนั้นให้ดูไปด้วย สามารถดูโค้ดเพื่อให้เข้าใจได้มากขึ้นว่ามีข้อผิดพลาดอะไร&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;การติดตั้ง介&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;sqlalchemy ไม่ใช่มอดูลมาตรฐานของไพธอน ต้องติดตั้งเพิ่มเติมเอง ซึ่งก็ทำได้ง่ายโดยใช้ pip&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;pip install SQLAlchemy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;หรือ conda&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;conda install -c anaconda sqlalchemy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;การเริ่มต้นเชื่อมต่อกับฐานข้อมูลเพื่อเตรียมการใช้งาน介&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ขอเริ่มด้วยการยกตัวอย่างการใช้ sqlalchemy ทำการเชื่อมต่อกับฐานข้อมูล สร้างตารางข้อมูลในนั้น จากนั้นเติมข้อมูลในตาราง และสุดท้ายคือดูข้อมูลในตาราง&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sqlalchemy
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base

# สร้างคลาสแบบจำลองพื้นฐาน
Base = declarative_base()

# สร้างคลาสตารางฐานข้อมูลนักเรียน
class Nakrian(Base):
    __tablename__ = &#39;nakrian&#39;
    chue = sqlalchemy.Column(sqlalchemy.String,primary_key=True)
    ayu = sqlalchemy.Column(sqlalchemy.Integer)
    sung = sqlalchemy.Column(sqlalchemy.Float)
    
    def __repr__(self):
        return f&#39;{self.chue} อายุ {self.ayu} สูง {self.sung*100:.0f} ซม.&#39;

# สร้างตัวเชื่อมต่อกับฐานข้อมูล sqlite ในไฟล์ yurudata.db
engine = sqlalchemy.create_engine(&#39;sqlite:///yurudata.db&#39;)

# ทำการสร้างตารางขึ้นมาในฐานข้อมูล SQL จริงๆ
Base.metadata.create_all(engine)

# สร้างเซชชัน
sm = sessionmaker(engine)
session = sm()



# เข้าสู่ขั้นตอนใช้งาน

# สร้างออบเจ็กต์นักเรียนคนแรก
nakrian1 = Nakrian(chue=&#39;ริเสะ&#39;,ayu=15,sung=1.46)
# ใส่นักเรียนคนแรกลงในฐานข้อมูล
session.add(nakrian1)

# สร้างออบเจ็กต์นักเรียนคนที่ ๒ และ ๓
nakrian2 = Nakrian(chue=&#39;อายาโนะ&#39;,ayu=14,sung=1.59)
nakrian3 = Nakrian(chue=&#39;ซากุราโกะ&#39;,ayu=13,sung=1.53)
# ใส่นักเรียนคนที่ ๒ และ ๓ ลงในฐานข้อมูลพร้อมกันทีเดียว
session.bulk_save_objects([nakrian2,nakrian3])

# บันทึกความเปลี่ยนแปลงลงในฐานข้อมูลจริงๆ
session.commit()

# เปิดดูข้อมูลทั้งหมดในฐานข้อมูล
for nakrian in session.query(Nakrian).order_by(Nakrian.ayu):
    print(nakrian)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ผลที่ได้&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;ซากุราโกะ อายุ 13 สูง 153 ซม.
อายาโนะ อายุ 14 สูง 159 ซม.
ริเสะ อายุ 15 สูง 146 ซม.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;จากตัวอย่างจะเห็นว่าขั้นตอนการเตรียมการใช้งานโดยรวมก็จะมีอยู่ดังนี้&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;สร้างคลาสแบบจำลองพื้นฐาน (Base) จาก sqlalchemy.ext.declarative.declarative_base()&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;สร้างคลาสตารางฐานข้อมูลนักเรียนขึ้นมาโดยรับทอดจากแบบจำลองพื้นฐานนั้น&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;สร้างออบเจ็กต์ตัวเชื่อมต่อกับฐานข้อมูล (ใน sqlalchemy จะเรียกว่าเป็น engine หรือเครื่องยนต์) โดยใช้ sqlalchemy.create_engine() แล้วระบุชื่อฐานข้อมูลที่จะเชื่อมต่อ&lt;/p&gt;

&lt;p&gt;ในกรณีของ SQLite ดังตัวอย่างนี้จะเขียนเป็น sqlalchemy.create_engine(&amp;lsquo;sqlite:///พาธและชื่อไฟล์ฐานข้อมูล&amp;rsquo;)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;สร้างตารางขึ้นตามแบบจำลองที่สร้างไว้ Base.metadata.create_all(engine)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;สร้างตัวสร้างเซชชันขึ้นมาจาก sqlalchemy.orm.sessionmaker()&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;สร้างเซชชันขึ้นมาจากตัวสร้างเซชชัน&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;หลังจากนั้นก็เข้าสู่ขั้นตอนการนำมาใช้งานได้ โดยสิ่งที่จะต้องใช้คือตัว session และตัวคลาสของตารางข้อมูลที่เราสร้างขึ้นมาจากขั้นเตรียมการ&lt;/p&gt;

&lt;p&gt;รายละเอียดในส่วนการใช้งานนั้นจะอธิบายอีกทีหลังในหัวข้อถัดๆไป&lt;/p&gt;

&lt;p&gt;ฟังก์ชันที่ใช้นั้นกระจัดกระจายอยู่ตามมอดูลย่อยต่างๆ ตัวหลักๆที่ใช้เป็นประจำมีดังนี้&lt;/p&gt;

&lt;p&gt;ชื่อฟังก์ชัน&lt;/p&gt;

&lt;p&gt;หน้าที่&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sqlalchemy.create_engine&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;สร้างตัวเชื่อมต่อกับฐานข้อมูล&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sqlalchemy.orm.sessionmaker&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ตัวสร้างเซสชันการเชื่อมต่อ&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sqlalchemy.ext.declarative.declarative_base&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ตัวสร้างคลาสที่เป็นฐานของแบบจำลองตารางข้อมูล&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sqlalchemy.Column&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;สร้างออบเจ็กต์ที่แทนสดมภ์ของตารางข้อมูล&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sqlalchemy.String&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;sqlalchemy.Integer&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;sqlalchemy.Float&lt;/code&gt;&lt;br /&gt;
ฯลฯ&lt;/p&gt;

&lt;p&gt;คลาสแทนชนิดข้อมูล สายอักขระ, เลขจำนวนเต็ม, เลขทศนิยม, ฯลฯ&lt;/p&gt;

&lt;p&gt;การแค่ import sqlalchemy เข้ามาอย่างเดียวไม่ได้ทำให้สามารถเรียกใช้พวก sqlalchemy.orm.sessionmaker() หรือ sqlalchemy.ext.declarative.declarative_base() ซึ่งอยู่ภายในมอดูลย่อยได้ ดังนั้นจึงต้องเขียน from import แยกออกมาอีกที&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;การสร้างคลาสตารางข้อมูล介&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ในส่วนของขั้นตอนการเตรียมตัวดังที่ยกตัวอย่างมาแล้วนั้น ขั้นตอนที่ดูจะซับซ้อนและต้องปรับแต่งอะไรมากที่สุดก็คือการสร้างคลาสของตารางข้อมูล&lt;/p&gt;

&lt;p&gt;เวลาสร้างคลาสนี้ขึ้นจะสร้างโดยรับทอดจากคลาส Base ซึ่งสร้างขึ้นมาจาก sqlalchemy.ext.declarative.declarative_base() อีกที&lt;/p&gt;

&lt;p&gt;ตัวอย่าง สร้างตารางข้อมูลผู้กล้าซึ่งมี ๓ สดมภ์คือ chue (ชื่อ), lv, hp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sqlalchemy
from sqlalchemy.ext.declarative import declarative_base

Basemodel = declarative_base()

class Phukla(Basemodel):
    __tablename__ = &#39;phukla&#39;
    chue = sqlalchemy.Column(sqlalchemy.String(32),primary_key=True)
    lv = sqlalchemy.Column(sqlalchemy.Integer)
    hp = sqlalchemy.Column(sqlalchemy.Float)
    
    def __repr__(self):
        return f&#39;{self.chue} lv: {self.lv} hp: {self.hp}&#39;

engine = sqlalchemy.create_engine(&#39;sqlite:///pukla.db&#39;)
Basemodel.metadata.create_all(engine)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sqlalchemy.Column() คือคลาสที่ใช้สร้างออบเจ็กต์สดมภ์ (column) ของตารางข้อมูล ต้องการให้ตารางมีข้อมูลอะไรบ้างก็ใส่ไปตามนั้น โดยในวงเล็บจะเป็นตัวกำหนดคุณสมบัติของสดมภ์นั้น ที่สำคัญที่สุดก็คือชนิดของข้อมูล ก็ให้ใส่โดยใช้ตัวคลาสที่เตรียมไว้ในตัวมอดูล sqlalchemy ได้แก่ String (สายอักขระ), Integer (เลขจำนวนเต็ม), Float (เลขทศนิยม), ฯลฯ&lt;/p&gt;

&lt;p&gt;สำหรับสายอักขระ หากต้องการจำกัดจำนวนตัวอักษรก็ใส่วงเล็บต่อ เช่น sqlalchemy.String(20) แบบนี้ แต่จะไม่ใส่ก็ได้&lt;/p&gt;

&lt;p&gt;นอกจากนี้หากต้องการให้สดมภ์ไหนเป็นไพรมารีคีย์ (สดมภ์ที่สำคัญที่สุดในตาราง และจะให้มีค่าซ้ำกันไม่ได้) ก็ใส่ primary_key=True ลงไป&lt;/p&gt;

&lt;p&gt;ในการใช้ sqlalchemy จำเป็นต้องกำหนดสดมภ์สักตัวหนึ่งให้เป็นไพรมารีคีย์เสมอ&lt;/p&gt;

&lt;p&gt;ปกติแล้วแค่กำหนดคอลัมน์ลงไปแบบนี้ ตอนที่สั่งสร้างอินสแตนซ์ขึ้นมาก็ใส่ชื่อสดมภ์ต่างๆเหล่านั้นลงไปเป็นคีย์เวิร์ด&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;phukla1 = Phukla(chue=&#39;ได&#39;,lv=99,hp=999)
print(phukla1) # ได้ ได lv: 99 hp: 999
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ตรงส่วน &lt;strong&gt;repr&lt;/strong&gt; นี้ใส่ลงไปเพื่อกำหนดว่าเวลาสั่ง print ขึ้นมาจะให้แสดงค่าเป็นแบบไหน อาจจะไม่ได้จำเป็นต้องใส่ แต่สะดวกเวลาแสดงผล จะได้รู้ว่าข้อมูลตัวนี้เป็นตัวไหน มีค่าอะไรอย่างไร&lt;/p&gt;

&lt;p&gt;หากไม่เขียน &lt;strong&gt;repr&lt;/strong&gt; เมื่อสั่ง print ก็คงจะออกมาในลักษณะแบบนี้&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;__main__.Phukla at 0x11b2a5090&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ซึ่งก็ไม่ได้แสดงข้อมูลในนี้ให้เห็นโดยตรง จึงอาจจะไม่สะดวก ดังนั้นตัวอย่างต่อจากนี้ไปก็จะใส่ &lt;strong&gt;repr&lt;/strong&gt; ไปด้วยตลอด&lt;/p&gt;

&lt;p&gt;นอกจากนี้แล้วอาจกำหนดตรงส่วนของ &lt;strong&gt;init&lt;/strong&gt; เพื่อให้ตอนสร้างง่ายขึ้นหน่อย เช่นแค่ใส่เป็นอาร์กิวเมนต์ลงไปตามลำดับ รวมทั้งกำหนดค่าเริ่มต้นให้ได้ด้วย เช่น&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Nangsue(Basemodel):
    __tablename__ = &#39;nangsue&#39;
    chue = sqlalchemy.Column(sqlalchemy.String,primary_key=True)
    chamnuanna = sqlalchemy.Column(sqlalchemy.Integer)
    rakha = sqlalchemy.Column(sqlalchemy.Float)
    
    def __init__(self,chue,chamnuanna=100,rakha=200):
        self.chue = chue
        self.chamnuanna = chamnuanna
        self.rakha = rakha
    
    def __repr__(self):
        return f&#39;หนังสือชื่อ &amp;quot;{self.chue}&amp;quot; มี {self.chamnuanna} หน้า ราคา {self.rakha} บาท&#39;

ns = Nangsue(&#39;สอนแมวเขียนโปรแกรม&#39;,400)
print(ns) # ได้ หนังสือชื่อ &amp;quot;สอนแมวเขียนโปรแกรม&amp;quot; มี 400 หน้า ราคา 200 บาท
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;นอกจากนี้ขั้นตอนสำคัญอีกอย่างก็คือการทำให้ตารางถูกสร้างขึ้นมาจริงๆในฐานข้อมูลด้วย&lt;/p&gt;

&lt;p&gt;การสร้างคลาสขึ้นมานั้นยังไม่ได้ทำให้ตารางถูกสร้างขึ้นมาในฐานข้อมูลจริงๆทันที ก่อนจะใช้งานจริงต้องสั่งสร้างตารางก่อน ซึ่งทำได้โดยสั่ง Base.metadata.create_all()&lt;/p&gt;

&lt;p&gt;Base นี้ก็คือตัวคลาสฐานที่ใช้ตอนรับทอดคลาสตารางข้อมูลนี้มา หากมีข้อมูลที่อยากให้สร้างขึ้นมาพร้อมกันก็ให้รับทอดจาก Base อันนี้เหมือนกัน แล้วเมื่อสั่ง .metadata.create_all() ก็จะสร้างขึ้นมาใหม่ทั้งหมด ถ้าหากยังไม่ได้มีอยู่ก่อน แต่ถ้าอันไหนมีแล้วก็จะไม่เกิดอะไรขึ้น&lt;/p&gt;

&lt;p&gt;ในทางกลับกัน ถ้าหากต้องการลบตารางข้อมูลทั้งหมดในฐานนั้นก็สั่ง Base.metadata.drop_all()&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;การเตรียมไฟล์แบบจำลองและตัวสร้างเซสชัน介&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;นอกจากตัวคลาสแบบจำลองแล้ว อีกสิ่งที่ต้องเตรียมการก็คือเซสชัน (session) ซึ่งสร้างจาก sqlalchemy.orm.sessionmaker&lt;/p&gt;

&lt;p&gt;เซสชันเป็นตัวกลางเชื่อมต่อกับ engine อีกที เวลาสร้าง sessionmaker ให้ใส่ engine ที่จะทำการเชื่อมต่อลงไป&lt;/p&gt;

&lt;p&gt;สิ่งที่ได้จาก sessionmaker คือตัวคลาสที่เอาไว้สร้างเซสชันอีกที ยังไม่ใช่ตัวเซสชัน ต้องเอามาเรียกใช้โดยสั่ง () เพื่อสร้างเซสชันอีกที&lt;/p&gt;

&lt;p&gt;ปกติแล้วส่วนของแบบจำลองและส่วนสร้างเซสชันอาจจะถูกเก็บไว้ในไฟล์หนึ่ง แล้วก็ให้เรียกใช้ไฟล์นั้นขึ้นมาในฐานะมอดูล โดย import เอาตัวคลาสและเซสชันมาใช้&lt;/p&gt;

&lt;p&gt;เพื่อเป็นตัวอย่างสำหรับหัวข้อถัดๆไป ขอสร้างแบบจำลองและเซสชันนี้ขึ้นมาใส่ในไฟล์ชื่อ pkmoses.py&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sqlalchemy
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base

Basemodel = declarative_base()

class Pokemon(Basemodel):
    __tablename__ = &#39;pokemon&#39;
    lek = sqlalchemy.Column(sqlalchemy.Integer,primary_key=True)
    chue = sqlalchemy.Column(sqlalchemy.String(32))
    nak = sqlalchemy.Column(sqlalchemy.Float)
    sung = sqlalchemy.Column(sqlalchemy.Float)
    
    def __init__(self,lek,chue,nak,sung):
        self.lek = lek
        self.chue = chue
        self.nak = nak
        self.sung = sung
    
    def __repr__(self):
        return f&#39;{self.lek}. {self.chue} หนัก {self.nak} สูง {self.sung*100:.0f} ซม.&#39;

engine = sqlalchemy.create_engine(&#39;sqlite:///pkdata.db&#39;)
Basemodel.metadata.create_all(engine)

Session = sessionmaker(engine)
session = Session()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ข้อมูลในตารางนี้ก็คือข้อมูล pokemon ซึ่งมี ๔ สดมภ์ ได้แก่ lek (เลข), chue (ชื่อ), nak (หนัก), sung (สูง) โดยใช้เลขเป็นไพรมารีคีย์&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;การเพิ่มข้อมูลลงไป介&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;หลังจากขั้นตอนการสร้างตาราง ก็เข้าสู่ขั้นตอนการใช้งาน โดยคำสั่งพื้นฐานที่สุดก็คือการใส่ข้อมูลเข้าไป&lt;/p&gt;

&lt;p&gt;การใส่ข้อมูลอาจมีขั้นตอนดังนี้&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;สร้างออบเจ็กต์ที่เป็นอินสแตนซ์ของคลาสตารางข้อมูลขึ้นมา&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ใส่ข้อมูลลงในฐานข้อมูลจริงๆ โดยใช้ session.add (ถ้ามีตัวเดียว) หรือ session.add_all หรือ session.bulk_save_objects (ถ้ามีหลายตัว)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;session.commit() เพื่อให้ข้อมูลถูกบันทึกไปจริงๆ&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ตัวอย่างการใช้งาน ให้ import ตัวคลาสแบบจำลองและ session จาก pkmoses ที่สร้างขึ้นมาจากไฟล์ที่สร้างจากในหัวข้อที่แล้ว แล้วเพิ่มข้อมูลลงไปตัวหนึ่งด้วย .add()&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pkmoses import session,Pokemon

poke1 = Pokemon(152,&#39;ชิโครีตา&#39;,6.4,0.9)
session.add(poke1)
session.commit()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;หากต้องการเพิ่มทีละหลายตัวอาจใช้ .add_all() หรือ .bulk_save_objects() ก็ได้&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;poke2 = Pokemon(155,&#39;ฮิโนอาราชิ&#39;,7.9,0.5)
poke3 = Pokemon(158,&#39;วานิโนโกะ&#39;,9.5,0.6)
session.bulk_save_objects([poke2,poke3])
session.commit()

poke4 = Pokemon(153,&#39;เบย์ลีฟ&#39;,15.8,1.2)
poke5 = Pokemon(154,&#39;เมกาเนียม&#39;,100.5,1.8)
session.add_all([poke4,poke5])
session.commit()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;เพียงแต่ข้อแตกต่างก็คือ .add_all() จะเป็นการสั่งให้วนซ้ำเพิ่มข้อมูลเข้าไปทีละตัวตามลำดับ ส่วน .bulk_save_objects() จะทำไปพร้อมกันและจะรวดเร็วกว่า&lt;/p&gt;

&lt;p&gt;ดังนั้นถ้าต้องการความรวดเร็วใช้ .bulk_save_objects() จะเร็วกว่า เพียงแต่เนื่องจากข้อมูลอาจถูกใส่อย่างไม่เป็นลำดับถูกต้อง ดังนั้นหากให้ความสำคัญกับลำดับของข้อมูลก็อาจใช้ .add_all()&lt;/p&gt;

&lt;p&gt;หลังสั่งเพิ่มข้อมูลทั้งหมดลงไปแล้วต้องสั่ง .commit() หากไม่มีการสั่ง .commit() ไปแม้จะใช้ .add() หรือ .add_all() หรือ .bulk_save_objects() ลงไปแล้วก็จะไม่มีการบันทึกลงไปจริงๆ&lt;/p&gt;

&lt;p&gt;อย่างไรก็ตาม หากต้องการให้มีการบันทึกไปเลยโดยอัตโนมัติทุกครั้งไม่ต้องมาสั่ง .commit() ก็ทำได้โดยตอนที่สร้างตัวสร้างเซสชันขึ้นให้ใส่เป็น sessionmaker(autocommit=True) ไป ก็เป็นวิธีหนึ่งที่ทำได้&lt;/p&gt;

&lt;p&gt;หากเพิ่มข้อมูลไปแล้วแต่ยังไม่ได้ .commit() แล้วต้องการยกเลิกความเปลี่ยนแปลงนั้นก็สามารถทำได้โดยใช้ .rollback()&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;การอ่านข้อมูลในตาราง (query)介&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;การอ่านข้อมูลที่อยู่ในตารางทำได้โดยใช้เมธอด .query() โดยใส่คลาสของตารางนั้นลงไป&lt;/p&gt;

&lt;p&gt;ข้อมูลที่อ่านขึ้นมาสามารถนำมาใช้วนด้วย for เพื่อเอาค่าทีละตัวก็ได้&lt;/p&gt;

&lt;p&gt;ตัวอย่างการอ่านข้อมูล&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for pk in session.query(Pokemon):
    print(pk)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ได้&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;152. ชิโครีตา หนัก 6.4 สูง 90 ซม.
153. เบย์ลีฟ หนัก 15.8 สูง 120 ซม.
154. เมกาเนียม หนัก 100.5 สูง 180 ซม.
155. ฮิโนอาราชิ หนัก 7.9 สูง 50 ซม.
158. วานิโนโกะ หนัก 9.5 สูง 60 ซม.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;กรณีที่ต้องการเอาข้อมูลแค่เฉพาะบางสดมภ์ให้ให้ใส่ตัวแอตทริบิวต์ที่เป็นชื่อตัวคอลัมน์ลงไปทีละตัวตามที่ต้องการ&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for pk in session.query(Pokemon.lek,Pokemon.chue):
    print(pk)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ได้&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(152, &#39;ชิโครีตา&#39;)
(153, &#39;เบย์ลีฟ&#39;)
(154, &#39;เมกาเนียม&#39;)
(155, &#39;ฮิโนอาราชิ&#39;)
(158, &#39;วานิโนโกะ&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;การอ่านข้อมูลทั้งหมดใส่ลิสต์ (all)介&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;วิธีการอ่านข้อมูลจากในตารางนอกจากจะใช้วนใน for แล้วก็ยังอาจจะใช้ .all() เพื่อดึงข้อมูลมาทั้งหมดทีเดียวเป็นลิสต์ก็ได้&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(session.query(Pokemon).all())
print(session.query(Pokemon.lek,Pokemon.chue).all())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ได้&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[152. ชิโครีตา หนัก 6.4 สูง 90 ซม., 153. เบย์ลีฟ หนัก 15.8 สูง 120 ซม., 154. เมกาเนียม หนัก 100.5 สูง 180 ซม., 155. ฮิโนอาราชิ หนัก 7.9 สูง 50 ซม., 158. วานิโนโกะ หนัก 9.5 สูง 60 ซม.]
[(152, &#39;ชิโครีตา&#39;), (153, &#39;เบย์ลีฟ&#39;), (154, &#39;เมกาเนียม&#39;), (155, &#39;ฮิโนอาราชิ&#39;), (158, &#39;วานิโนโกะ&#39;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;การกำหนดวิธีการเรียงลำดับข้อมูล (order_by)介&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;สามารถกำหนดลำดับการเรียงข้อมูลที่ออกมาได้โดยใส่ .order_by() โดยระบุสดมภ์ที่ต้องการใช้เรียงลงไป เช่น&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(session.query(Pokemon).order_by(Pokemon.sung).all())
print(session.query(Pokemon).order_by(Pokemon.nak).all())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ได้&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[155. ฮิโนอาราชิ หนัก 7.9 สูง 50 ซม., 158. วานิโนโกะ หนัก 9.5 สูง 60 ซม., 152. ชิโครีตา หนัก 6.4 สูง 90 ซม., 153. เบย์ลีฟ หนัก 15.8 สูง 120 ซม., 154. เมกาเนียม หนัก 100.5 สูง 180 ซม.]
[152. ชิโครีตา หนัก 6.4 สูง 90 ซม., 155. ฮิโนอาราชิ หนัก 7.9 สูง 50 ซม., 158. วานิโนโกะ หนัก 9.5 สูง 60 ซม., 153. เบย์ลีฟ หนัก 15.8 สูง 120 ซม., 154. เมกาเนียม หนัก 100.5 สูง 180 ซม.]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;หากต้องการเรียงกลับด้านให้ใส่ .desc() เช่น&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(session.query(Pokemon).order_by(Pokemon.lek.desc()).all())
print(session.query(Pokemon).order_by(Pokemon.sung.desc()).all())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ได้&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[158. วานิโนโกะ หนัก 9.5 สูง 60 ซม., 155. ฮิโนอาราชิ หนัก 7.9 สูง 50 ซม., 154. เมกาเนียม หนัก 100.5 สูง 180 ซม., 153. เบย์ลีฟ หนัก 15.8 สูง 120 ซม., 152. ชิโครีตา หนัก 6.4 สูง 90 ซม.]
[154. เมกาเนียม หนัก 100.5 สูง 180 ซม., 153. เบย์ลีฟ หนัก 15.8 สูง 120 ซม., 152. ชิโครีตา หนัก 6.4 สูง 90 ซม., 158. วานิโนโกะ หนัก 9.5 สูง 60 ซม., 155. ฮิโนอาราชิ หนัก 7.9 สูง 50 ซม.]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;การเอาข้อมูลเฉพาะตัวแรกตัวเดียว (first)介&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;หากต้องการข้อมูลเฉพาะแค่ตัวแรกให้ใช้ .first() เช่น&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(session.query(Pokemon).first())
# ได้ 152. ชิโครีตา หนัก 6.4 สูง 90 ซม.
print(session.query(Pokemon).order_by(Pokemon.sung).first())
# ได้ 155. ฮิโนอาราชิ หนัก 7.9 สูง 50 ซม.
print(session.query(Pokemon).order_by(Pokemon.nak.desc()).first())
# ได้ 154. เมกาเนียม หนัก 100.5 สูง 180 ซม.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;การจำกัดเอาข้อมูลเฉพาะบางส่วน (limit และ offset)介&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ถ้าต้องการจำกัดจำนวนที่จะเอาให้ใช้ .limit() และกำหนดลำดับเริ่มต้นโดยใช้ .offset() เช่น&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(session.query(Pokemon).limit(3).all())
# ได้ [152. ชิโครีตา หนัก 6.4 สูง 90 ซม., 153. เบย์ลีฟ หนัก 15.8 สูง 120 ซม., 154. เมกาเนียม หนัก 100.5 สูง 180 ซม.]
print(session.query(Pokemon.lek).limit(4).all())
# ได้ [(152,), (153,), (154,), (155,)]
print(session.query(Pokemon).offset(2).all())
# ได้ [154. เมกาเนียม หนัก 100.5 สูง 180 ซม., 155. ฮิโนอาราชิ หนัก 7.9 สูง 50 ซม., 158. วานิโนโกะ หนัก 9.5 สูง 60 ซม.]
print(session.query(Pokemon).offset(1).limit(2).all())
# ได้ [153. เบย์ลีฟ หนัก 15.8 สูง 120 ซม., 154. เมกาเนียม หนัก 100.5 สูง 180 ซม.]
print(session.query(Pokemon).order_by(Pokemon.sung).limit(2).all())
# ได้ [155. ฮิโนอาราชิ หนัก 7.9 สูง 50 ซม., 158. วานิโนโกะ หนัก 9.5 สูง 60 ซม.]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ถ้าใช้ order_by เพื่อกำหนดรูปแบบการเรียงไปด้วยให้ใส่ order_by ก่อนค่อยตามด้วย offset และ limit&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;การกำหนดเงื่อนไขข้อมูลที่จะอ่าน (filter)介&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;สามารถกำหนดเงื่อนไขว่าจะเอาข้อมูลแค่บางส่วนที่ต้องการออกมาได้โดยใช้ .filter() เช่น&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(session.query(Pokemon).filter(Pokemon.nak&amp;lt;10).all())
# ได้ [152. ชิโครีตา หนัก 6.4 สูง 90 ซม., 155. ฮิโนอาราชิ หนัก 7.9 สูง 50 ซม., 158. วานิโนโกะ หนัก 9.5 สูง 60 ซม.]
print(session.query(Pokemon.chue).filter(Pokemon.chue!=&#39;เบย์ลีฟ&#39;).all())
# ได้ [(&#39;ชิโครีตา&#39;,), (&#39;เมกาเนียม&#39;,), (&#39;ฮิโนอาราชิ&#39;,), (&#39;วานิโนโกะ&#39;,)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;สามารถใส่มากกว่าเงื่อนไขพร้อมกันได้ โดยจะมีความหมายเป็น &amp;laquo;และ&amp;raquo; คือต้องเข้าทุกเงื่อนไข&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(session.query(Pokemon).filter(Pokemon.nak&amp;gt;8,Pokemon.nak&amp;lt;20).all())
# ได้ [153. เบย์ลีฟ หนัก 15.8 สูง 120 ซม., 158. วานิโนโกะ หนัก 9.5 สูง 60 ซม.]
print(session.query(Pokemon.chue).filter(Pokemon.chue!=&#39;ชิโครีตา&#39;,Pokemon.chue!=&#39;เบย์ลีฟ&#39;).all())
# [(&#39;เมกาเนียม&#39;,), (&#39;ฮิโนอาราชิ&#39;,), (&#39;วานิโนโกะ&#39;,)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;นอกจากนี้ในการรวมหรือจัดการเงื่อนไขอาจใช้ and&lt;em&gt;, or&lt;/em&gt;, not_ เพื่อแทน &amp;laquo;และ&amp;raquo;, &amp;laquo;หรือ&amp;raquo;, &amp;laquo;ไม่&amp;raquo;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(session.query(Pokemon).filter(sqlalchemy.or_(Pokemon.chue==&amp;quot;เบย์ลีฟ&amp;quot;,Pokemon.chue==&amp;quot;เมกาเนียม&amp;quot;)).all())
# ได้ [153. เบย์ลีฟ หนัก 15.8 สูง 120 ซม., 154. เมกาเนียม หนัก 100.5 สูง 180 ซม.]
print(session.query(Pokemon.chue).filter(sqlalchemy.not_(Pokemon.chue==&amp;quot;ชิโครีตา&amp;quot;)).all())
# ได้ [(&#39;เบย์ลีฟ&#39;,), (&#39;เมกาเนียม&#39;,), (&#39;ฮิโนอาราชิ&#39;,), (&#39;วานิโนโกะ&#39;,)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;อนึ่ง สาเหตุที่ชื่อ and&lt;em&gt;, or&lt;/em&gt;, not_ มี _ ต่อท้ายเพราะคำว่า and, or, not เป็นคำต้องห้ามในไพธอน ใช้เป็นชื่อตัวแปรไม่ได้เลยต้องเติม _&lt;/p&gt;

&lt;p&gt;นอกจากนี้เงื่อนไขที่เป็นตัวเลขอาจใช้ .between() เพื่อคัดเอาค่าที่อยู่ในช่วงได้&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(session.query(Pokemon).filter(Pokemon.nak.between(9,25)).all())
# ได้ [153. เบย์ลีฟ หนัก 15.8 สูง 120 ซม., 158. วานิโนโกะ หนัก 9.5 สูง 60 ซม.]
print(session.query(Pokemon).filter(Pokemon.lek.between(153,155)).all())
# ได้ [153. เบย์ลีฟ หนัก 15.8 สูง 120 ซม., 154. เมกาเนียม หนัก 100.5 สูง 180 ซม., 155. ฮิโนอาราชิ หนัก 7.9 สูง 50 ซม.]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ถ้าค่าเป็นสายอักขระอาจใช้ .contains() เพื่อคัดเอาที่มีคำที่ต้องการอยู่&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(session.query(Pokemon.chue).filter(Pokemon.chue.contains(&#39;โน&#39;)).all())
# ได้ [(&#39;ฮิโนอาราชิ&#39;,), (&#39;วานิโนโกะ&#39;,)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;การแก้ข้อมูล (update)介&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;การแก้ไขข้อมูลอาจทำโดยใช้ .query อ่านข้อมูลเข้ามา() แล้วเอามาแก้ แล้วก็ทำการ .commit() ข้อมูลในฐานข้อมูลก็จะถูกแก้ไปด้วยตามนั้น&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;pk1 = session.query(Pokemon).filter(Pokemon.chue==&#39;ฮิโนอาราชิ&#39;).first()
pk1.lek = 156
pk1.chue = &#39;แม็กมาราชิ&#39;
pk1.nak = 0.9
pk1.sung = 19
session.commit()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;นอกจากนี้ก็อาจใช้เมธอด .update() ที่ตัวข้อมูลที่ใช้ .filter() คัดมา เพื่อสั่งแก้ข้อมูลโดยตรง เช่น&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;kha = {&#39;lek&#39;:159,&#39;chue&#39;:&#39;อาลิเกตซ์&#39;,&#39;nak&#39;:1.1,&#39;sung&#39;:25}
session.query(Pokemon).filter(Pokemon.chue==&#39;วานิโนโกะ&#39;).update(kha)
session.commit()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;การลบข้อมูลออก (delete)介&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;การลบข้อมูลออกอาจทำโดยใช้ .query() ดึงข้อมูลที่ต้องการลบออกมา แล้วใช้เมธอด .delete() จากตัวเซสชัน แล้ว .commit()&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;pk2 = session.query(Pokemon).filter(Pokemon.chue==&#39;เมกาเนียม&#39;).first()
session.delete(pk2)
session.commit()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;นอกจากนี้อาจจะเรียกเมธอด .delete() จากตัว query โดยตรงเลยก็ได้ เช่น&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;session.query(Pokemon).filter(Pokemon.chue==&#39;ชิโครีตา&#39;).delete()
session.commit()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;การย้อนคืนสิ่งที่ทำกลับไป (rollback)介&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;หากเพิ่มหรือแก้ไขหรือลบข้อมูลไปแล้วยังไม่ได้สั่ง .commit() ที่ตัวเซสชันอาจสามารถย้อนคืนกลับได้โดยใช้ .rollback()น&lt;/p&gt;

&lt;p&gt;ตัวอย่างการใช้&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(session.query(Pokemon).all())
# ได้ [153. เบย์ลีฟ หนัก 15.8 สูง 120 ซม., 156. แม็กมาราชิ หนัก 0.9 สูง 1900 ซม., 159. อาลิเกตซ์ หนัก 1.1 สูง 2500 ซม.]

kha = {&#39;lek&#39;:157,&#39;chue&#39;:&#39;บักฟูน&#39;,&#39;nak&#39;:1.7,&#39;sung&#39;:79.5}
session.query(Pokemon).filter(Pokemon.chue==&#39;แม็กมาราชิ&#39;).update(kha)
session.query(Pokemon).filter(Pokemon.chue==&#39;เบย์ลีฟ&#39;).delete()

print(session.query(Pokemon).all())
# ได้ [157. บักฟูน หนัก 1.7 สูง 7950 ซม., 159. อาลิเกตซ์ หนัก 1.1 สูง 2500 ซม.]

session.rollback()
print(session.query(Pokemon).all())
# ได้ [153. เบย์ลีฟ หนัก 15.8 สูง 120 ซม., 156. แม็กมาราชิ หนัก 0.9 สูง 1900 ซม., 159. อาลิเกตซ์ หนัก 1.1 สูง 2500 ซม.]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;อาจนำมาใช้เพื่อรับมือในกรณีที่เกิดข้อผิดพลาด เช่น&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;try:
    oda = Pokemon(160,&#39;ออร์ไดล์&#39;,&#39;ไม่ทราบ&#39;,2.3)
    session.add(oda)
    session.commit()
except sqlalchemy.exc.SQLAlchemyError as e:
    session.rollback()
    print(&#39;เกิดข้อผิดพลาด\n&#39;,e)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ได้&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;เกิดข้อผิดพลาด
 (builtins.ValueError) could not convert string to float: &#39;ไม่ทราบ&#39;
[SQL: INSERT INTO pokemon (lek, chue, nak, sung) VALUES (?, ?, ?, ?)]
[parameters: [{&#39;sung&#39;: 2.3, &#39;lek&#39;: 160, &#39;chue&#39;: &#39;ออร์ไดล์&#39;, &#39;nak&#39;: &#39;ไม่ทราบ&#39;}]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sqlalchemy.exc.SQLAlchemyError คือคลาสของความผิดพลาดที่จะเกิดขึ้นเมื่อมีปัญหาในการติดต่อกับฐานข้อมูล SQL จะมีการอธิบายรายละเอียดว่าโค้ด SQL ที่ส่งไปจริงๆเป็นอย่างไร และผิดพลาดที่ตรงไหน&lt;/p&gt;

&lt;p&gt;อย่างตัวอย่างนี้ไปใส่ nak ว่า &amp;lsquo;ไม่ทราบ&amp;rsquo; ทั้งที่จริงๆควรจะเป็นตัวเลข ก็เลยเกิดข้อผิดพลาดขึ้น&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;การป้อนคำสั่ง SQL ใส่โดยตรง (execute)介&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;นอกจากจะใช้เมธอดต่างๆที่ sqlalchemy เตรียมไว้ให้แล้ว หากต้องการพิมพ์โค้ด SQL เพื่อป้อนคำสั่งสั่งฐานข้อมูลโดยตรงก็สามารถทำผ่าน sqlalchemy ได้เช่นกัน โดยใช้เมธอด .execute() ซึ่งอาจเรียกจากตัว engine หรือตัว session ก็ได้&lt;/p&gt;

&lt;p&gt;ไม่ว่าขั้นตอนไหนก็สามารถใช้ .execute() ทำแทนได้ เช่น&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sqlalchemy
from sqlalchemy.orm import sessionmaker
engine = sqlalchemy.create_engine(&#39;sqlite:///pikadata.db&#39;)
engine.execute(&#39;create table pokemon (lek integer,chue text,nak real,sung real)&#39;)
engine.execute(&#39;insert into pokemon (lek,chue,nak,sung) values (25,&amp;quot;พิคาชู&amp;quot;,6,0.4)&#39;)
print(engine.execute(&#39;select * from pokemon&#39;).fetchall())
# ได้ [(25, &#39;พิคาชู&#39;, 6.0, 0.4)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;เมื่อใช้ execute กับ select ก็จะเอาผลที่ได้มาใช้ .fetchall() หรือวนด้วย for เพื่อเอาข้อมูลได้ เหมือนกับที่ใช้ sqlite3 โดยตรง&lt;/p&gt;

&lt;p&gt;เพียงแต่หากจะใช้ .execute() สั่งไปทั้งหมดแบบนี้ก็ไม่ต่างจากใช้ sqlite3 โดยตรง อาจไม่มีความหมายที่จะใช้ sqlalchemy นัก&lt;/p&gt;

&lt;p&gt;.execute() อาจจะใช้แค่บางส่วน แค่ในกรณีที่ต้องการสั่งคำสั่งที่ไม่สะดวกจะทำผ่านเมธอดต่างๆของ sqlalchemy เอง ซึ่งอาจมีความจำเป็นบ้างเพราะโค้ดจับคู่เชื่อมต่อก็ไม่ได้ทำทุกอย่างไว้สมบูรณ์แบบทั้งหมด&lt;/p&gt;

&lt;p&gt;หลักการใช้ยังมีรายละเอียดอีกมากมาย นี่เป็นเพียงแค่เบื้องต้นส่วนหนึ่งเท่านั้น อาจอ่านเพิ่มเติมได้ใน&lt;a href=&#34;https://www.sqlalchemy.org/&#34; target=&#34;_blank&#34;&gt;เว็บหลักของ sqlalchemy&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Reference : &lt;a href=&#34;https://phyblas.hinaboshi.com/20200529&#34; target=&#34;_blank&#34;&gt;https://phyblas.hinaboshi.com/20200529&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
  </channel>
</rss>
