<!DOCTYPE html>
<html lang="en-us">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Source Themes Academia 4.3.1">
  <meta name="generator" content="Hugo 0.59.1" />

  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="Little Dragon">

  
  
  
    
  
  <meta name="description" content="Up to this point we&rsquo;ve been focused primarily on one-dimensional and two-dimensional data, stored in Pandas Series and DataFrame objects, respectively. Often it is useful to go beyond this and store higher-dimensional data–that is, data indexed by more than one or two keys. While Pandas does provide Panel and Panel4D objects that natively handle three-dimensional and four-dimensional data (see Aside: Panel Data), a far more common pattern in practice is to make use of hierarchical indexing (also known as multi-indexing) to incorporate multiple index levels within a single index.">

  
  <link rel="alternate" hreflang="en-us" href="https://dragon-library.github.io/coding/tutorials/data-science-handbook/3.pandas/03.05-hierarchical-indexing/">

  


  

  
  
  
  <meta name="theme-color" content="#c7254e">
  

  
  
  
  
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css" integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.0/css/all.css" integrity="sha384-aOkxzJ5uQz7WBObEZcHvV5JvRW3TUc2rNPA7pe3AwnsUohiw1Vj2Rgx2KSOkF5+h" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" integrity="sha256-ygkqlh3CYSUri3LhQxzdcm0n1EQvH2Y+U5S2idbLtxs=" crossorigin="anonymous">

    
    
    
      
    
    
      
      
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/github.min.css" crossorigin="anonymous" title="hl-light">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/github.min.css" crossorigin="anonymous" title="hl-dark" disabled>
      
    

    

    

  

  
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Kanit:400,700|Sarabun|Roboto&display=swap">
  

  
  
  
  <link rel="stylesheet" href="/coding/css/academia.min.ff05a21b53038f9dccb7f30aedbfb6d7.css">

  

  
  
  

  

  <link rel="manifest" href="/coding/site.webmanifest">
  <link rel="icon" type="image/png" href="/coding/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/coding/img/icon-192.png">

  <link rel="canonical" href="https://dragon-library.github.io/coding/tutorials/data-science-handbook/3.pandas/03.05-hierarchical-indexing/">

  
  
  
  
    
    
  
  <meta property="twitter:card" content="summary">
  
  <meta property="og:site_name" content="Library">
  <meta property="og:url" content="https://dragon-library.github.io/coding/tutorials/data-science-handbook/3.pandas/03.05-hierarchical-indexing/">
  <meta property="og:title" content="Hierarchical Indexing | Library">
  <meta property="og:description" content="Up to this point we&rsquo;ve been focused primarily on one-dimensional and two-dimensional data, stored in Pandas Series and DataFrame objects, respectively. Often it is useful to go beyond this and store higher-dimensional data–that is, data indexed by more than one or two keys. While Pandas does provide Panel and Panel4D objects that natively handle three-dimensional and four-dimensional data (see Aside: Panel Data), a far more common pattern in practice is to make use of hierarchical indexing (also known as multi-indexing) to incorporate multiple index levels within a single index."><meta property="og:image" content="https://dragon-library.github.io/coding/img/icon-192.png">
  <meta property="twitter:image" content="https://dragon-library.github.io/coding/img/icon-192.png"><meta property="og:locale" content="en-us">
  
  <meta property="article:published_time" content="2020-06-18T00:00:00&#43;00:00">
  
  <meta property="article:modified_time" content="2020-06-19T01:41:59&#43;07:00">
  

  


  





  <title>Hierarchical Indexing | Library</title>

</head>


<body id="top" data-spy="scroll" data-target="#TableOfContents" data-offset="71" >

  <aside class="search-results" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
        autocomplete="off" autocorrect="off" role="textbox" spellcheck="false" type="search">
        
      </div>

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>


  
<nav class="navbar navbar-light fixed-top navbar-expand-lg py-0" id="navbar-main">
  <div class="container">

    
      <a class="navbar-brand" href="/coding/">Library</a>
      
      <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation"><span><i class="fas fa-bars"></i></span>
      </button>
      

    
    <div class="collapse navbar-collapse" id="navbar">

      
      
      <ul class="navbar-nav ml-auto">
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/coding/#about"><span>Home</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link " href="/coding/python/"><span>Python</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/coding/#posts"><span>Posts</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link  active" href="/coding/tutorials/"><span>Tutorials</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/coding/#publications"><span>Publications</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link  active" href="/coding/book/"><span>Book</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link " href="/coding/courses/"><span>Courses</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/coding/#contact"><span>Contact</span></a>
        </li>

        
        

      

        

        
        <li class="nav-item">
          <a class="nav-link js-search" href="#"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        

        
        <li class="nav-item">
          <a class="nav-link js-dark-toggle" href="#"><i class="fas fa-moon" aria-hidden="true"></i></a>
        </li>
        

      </ul>

    </div>
  </div>
</nav>


  

<div class="container-fluid docs">
  <div class="row flex-xl-nowrap">
    <div class="col-12 col-md-3 col-xl-2 docs-sidebar">
      





<form class="docs-search d-flex align-items-center">
  <button class="btn docs-toggle d-md-none p-0 mr-3" type="button" data-toggle="collapse" data-target="#docs-nav" aria-controls="docs-nav" aria-expanded="false" aria-label="Toggle section navigation">
    <span><i class="fas fa-bars"></i></span>
  </button>

  
  <input name="q" type="search" class="form-control" id="search-query" placeholder="Search..." autocomplete="off">
  
</form>

<nav class="collapse docs-links" id="docs-nav">
  
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/coding/tutorials/data-science-handbook/intro/_index/">DS Handbook</a>
    <ul class="nav docs-sidenav">
      
      <li >
        <a href="/coding/tutorials/data-science-handbook/intro/00.00-preface/">Preface</a>
      </li>
      
    </ul>
    

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/coding/tutorials/data-science-handbook/1.ipython/main/">1. IPython</a>
    <ul class="nav docs-sidenav">
      
      <li >
        <a href="/coding/tutorials/data-science-handbook/1.ipython/main/">Beyond Normal</a>
      </li>
      
      <li >
        <a href="/coding/tutorials/data-science-handbook/1.ipython/01.01-help-and-documentation/">Help and Documentation</a>
      </li>
      
      <li >
        <a href="/coding/tutorials/data-science-handbook/1.ipython/01.02-shell-keyboard-shortcuts/">Keyboard Shortcuts</a>
      </li>
      
    </ul>
    

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/coding/tutorials/data-science-handbook/3.pandas/intro/">3. Pandas</a>
    <ul class="nav docs-sidenav">
      
      <li >
        <a href="/coding/tutorials/data-science-handbook/3.pandas/intro/">Introducing</a>
      </li>
      
      <li >
        <a href="/coding/tutorials/data-science-handbook/3.pandas/03.02-data-indexing-and-selection/">Data Indexing and Selection</a>
      </li>
      
      <li >
        <a href="/coding/tutorials/data-science-handbook/3.pandas/03.03-operations-in-pandas/">Operating on Data</a>
      </li>
      
      <li >
        <a href="/coding/tutorials/data-science-handbook/3.pandas/03.04-missing-values/">Handling Missing Data</a>
      </li>
      
      <li class="active">
        <a href="/coding/tutorials/data-science-handbook/3.pandas/03.05-hierarchical-indexing/">Hierarchical Indexing</a>
      </li>
      
      <li >
        <a href="/coding/tutorials/data-science-handbook/3.pandas/03.06-concat-and-append/">Concat and Append</a>
      </li>
      
      <li >
        <a href="/coding/tutorials/data-science-handbook/3.pandas/03.07-merge-and-join/">Merge and Join</a>
      </li>
      
      <li >
        <a href="/coding/tutorials/data-science-handbook/3.pandas/03.08-aggregation-and-grouping/">Grouping</a>
      </li>
      
      <li >
        <a href="/coding/tutorials/data-science-handbook/3.pandas/03.09-pivot-tables/">Pivot Tables</a>
      </li>
      
      <li >
        <a href="/coding/tutorials/data-science-handbook/3.pandas/03.10-working-with-strings/">String Operations</a>
      </li>
      
      <li >
        <a href="/coding/tutorials/data-science-handbook/3.pandas/03.11-working-with-time-series/03.11-working-with-time-series/">Time Series</a>
      </li>
      
      <li >
        <a href="/coding/tutorials/data-science-handbook/3.pandas/03.12-performance-eval-and-query/">eval() and query()</a>
      </li>
      
      <li >
        <a href="/coding/tutorials/data-science-handbook/3.pandas/03.13-further-resources/">Further Resources</a>
      </li>
      
    </ul>
    

  </div>
  
  
</nav>

    </div>

    
    <div class="d-none d-xl-block col-xl-2 docs-toc">
      <ul class="nav toc-top">
        <li><a href="#" id="back_to_top" class="docs-toc-title">Contents</a></li>
      </ul>

      <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#a-multiply-indexed-series">A Multiply Indexed Series</a>
<ul>
<li><a href="#the-bad-way">The bad way</a></li>
<li><a href="#the-better-way-pandas-multiindex">The Better Way: Pandas MultiIndex</a></li>
<li><a href="#multiindex-as-extra-dimension">MultiIndex as extra dimension</a></li>
</ul></li>
<li><a href="#methods-of-multiindex-creation">Methods of MultiIndex Creation</a>
<ul>
<li><a href="#explicit-multiindex-constructors">Explicit MultiIndex constructors</a></li>
<li><a href="#multiindex-level-names">MultiIndex level names</a></li>
<li><a href="#multiindex-for-columns">MultiIndex for columns</a></li>
</ul></li>
<li><a href="#indexing-and-slicing-a-multiindex">Indexing and Slicing a MultiIndex</a>
<ul>
<li><a href="#multiply-indexed-series">Multiply indexed Series</a></li>
<li><a href="#multiply-indexed-dataframes">Multiply indexed DataFrames</a></li>
</ul></li>
<li><a href="#rearranging-multi-indices">Rearranging Multi-Indices</a>
<ul>
<li><a href="#sorted-and-unsorted-indices">Sorted and unsorted indices</a></li>
<li><a href="#stacking-and-unstacking-indices">Stacking and unstacking indices</a></li>
<li><a href="#index-setting-and-resetting">Index setting and resetting</a></li>
</ul></li>
<li><a href="#data-aggregations-on-multi-indices">Data Aggregations on Multi-Indices</a></li>
<li><a href="#aside-panel-data">Aside: Panel Data</a></li>
</ul></li>
</ul>
</nav>

      
    </div>
    

    <main class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 docs-content" role="main">

      <article class="article" itemscope itemtype="http://schema.org/Article">

        <div class="docs-article-container">
          <h1 itemprop="name">Hierarchical Indexing</h1>

          <div class="article-style" itemprop="articleBody">
            

<p>Up to this point we&rsquo;ve been focused primarily on one-dimensional and two-dimensional data, stored in Pandas <code>Series</code> and <code>DataFrame</code> objects, respectively.
Often it is useful to go beyond this and store higher-dimensional data–that is, data indexed by more than one or two keys.
While Pandas does provide <code>Panel</code> and <code>Panel4D</code> objects that natively handle three-dimensional and four-dimensional data (see <a href="#Aside:-Panel-Data">Aside: Panel Data</a>), a far more common pattern in practice is to make use of <em>hierarchical indexing</em> (also known as <em>multi-indexing</em>) to incorporate multiple index <em>levels</em> within a single index.
In this way, higher-dimensional data can be compactly represented within the familiar one-dimensional <code>Series</code> and two-dimensional <code>DataFrame</code> objects.</p>

<p>In this section, we&rsquo;ll explore the direct creation of <code>MultiIndex</code> objects, considerations when indexing, slicing, and computing statistics across multiply indexed data, and useful routines for converting between simple and hierarchically indexed representations of your data.</p>

<p>We begin with the standard imports:</p>

<pre><code class="language-python">import pandas as pd
import numpy as np
</code></pre>

<h2 id="a-multiply-indexed-series">A Multiply Indexed Series</h2>

<p>Let&rsquo;s start by considering how we might represent two-dimensional data within a one-dimensional <code>Series</code>.
For concreteness, we will consider a series of data where each point has a character and numerical key.</p>

<h3 id="the-bad-way">The bad way</h3>

<p>Suppose you would like to track data about states from two different years.
Using the Pandas tools we&rsquo;ve already covered, you might be tempted to simply use Python tuples as keys:</p>

<pre><code class="language-python">index = [('California', 2000), ('California', 2010),
         ('New York', 2000), ('New York', 2010),
         ('Texas', 2000), ('Texas', 2010)]
populations = [33871648, 37253956,
               18976457, 19378102,
               20851820, 25145561]
pop = pd.Series(populations, index=index)
pop
</code></pre>

<pre><code>(California, 2000)    33871648
(California, 2010)    37253956
(New York, 2000)      18976457
(New York, 2010)      19378102
(Texas, 2000)         20851820
(Texas, 2010)         25145561
dtype: int64
</code></pre>

<p>With this indexing scheme, you can straightforwardly index or slice the series based on this multiple index:</p>

<pre><code class="language-python">pop[('California', 2010):('Texas', 2000)]
</code></pre>

<pre><code>(California, 2010)    37253956
(New York, 2000)      18976457
(New York, 2010)      19378102
(Texas, 2000)         20851820
dtype: int64
</code></pre>

<p>But the convenience ends there. For example, if you need to select all values from 2010, you&rsquo;ll need to do some messy (and potentially slow) munging to make it happen:</p>

<pre><code class="language-python">pop[[i for i in pop.index if i[1] == 2010]]
</code></pre>

<pre><code>(California, 2010)    37253956
(New York, 2010)      19378102
(Texas, 2010)         25145561
dtype: int64
</code></pre>

<p>This produces the desired result, but is not as clean (or as efficient for large datasets) as the slicing syntax we&rsquo;ve grown to love in Pandas.</p>

<h3 id="the-better-way-pandas-multiindex">The Better Way: Pandas MultiIndex</h3>

<p>Fortunately, Pandas provides a better way.
Our tuple-based indexing is essentially a rudimentary multi-index, and the Pandas <code>MultiIndex</code> type gives us the type of operations we wish to have.
We can create a multi-index from the tuples as follows:</p>

<pre><code class="language-python">index = pd.MultiIndex.from_tuples(index)
index
</code></pre>

<pre><code>MultiIndex(levels=[['California', 'New York', 'Texas'], [2000, 2010]],
           codes=[[0, 0, 1, 1, 2, 2], [0, 1, 0, 1, 0, 1]])
</code></pre>

<p>Notice that the <code>MultiIndex</code> contains multiple <em>levels</em> of indexing–in this case, the state names and the years, as well as multiple <em>labels</em> for each data point which encode these levels.</p>

<p>If we re-index our series with this <code>MultiIndex</code>, we see the hierarchical representation of the data:</p>

<pre><code class="language-python">pop = pop.reindex(index)
pop
</code></pre>

<pre><code>California  2000    33871648
            2010    37253956
New York    2000    18976457
            2010    19378102
Texas       2000    20851820
            2010    25145561
dtype: int64
</code></pre>

<p>Here the first two columns of the <code>Series</code> representation show the multiple index values, while the third column shows the data.
Notice that some entries are missing in the first column: in this multi-index representation, any blank entry indicates the same value as the line above it.</p>

<p>Now to access all data for which the second index is 2010, we can simply use the Pandas slicing notation:</p>

<pre><code class="language-python">pop[:, 2010]
</code></pre>

<pre><code>California    37253956
New York      19378102
Texas         25145561
dtype: int64
</code></pre>

<p>The result is a singly indexed array with just the keys we&rsquo;re interested in.
This syntax is much more convenient (and the operation is much more efficient!) than the home-spun tuple-based multi-indexing solution that we started with.
We&rsquo;ll now further discuss this sort of indexing operation on hieararchically indexed data.</p>

<h3 id="multiindex-as-extra-dimension">MultiIndex as extra dimension</h3>

<p>You might notice something else here: we could easily have stored the same data using a simple <code>DataFrame</code> with index and column labels.
In fact, Pandas is built with this equivalence in mind. The <code>unstack()</code> method will quickly convert a multiply indexed <code>Series</code> into a conventionally indexed <code>DataFrame</code>:</p>

<pre><code class="language-python">pop_df = pop.unstack()
pop_df
</code></pre>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>2000</th>
      <th>2010</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>California</th>
      <td>33871648</td>
      <td>37253956</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>18976457</td>
      <td>19378102</td>
    </tr>
    <tr>
      <th>Texas</th>
      <td>20851820</td>
      <td>25145561</td>
    </tr>
  </tbody>
</table>
</div>

<p>Naturally, the <code>stack()</code> method provides the opposite operation:</p>

<pre><code class="language-python">pop_df.stack()
</code></pre>

<pre><code>California  2000    33871648
            2010    37253956
New York    2000    18976457
            2010    19378102
Texas       2000    20851820
            2010    25145561
dtype: int64
</code></pre>

<p>Seeing this, you might wonder why would we would bother with hierarchical indexing at all.
The reason is simple: just as we were able to use multi-indexing to represent two-dimensional data within a one-dimensional <code>Series</code>, we can also use it to represent data of three or more dimensions in a <code>Series</code> or <code>DataFrame</code>.
Each extra level in a multi-index represents an extra dimension of data; taking advantage of this property gives us much more flexibility in the types of data we can represent. Concretely, we might want to add another column of demographic data for each state at each year (say, population under 18) ; with a <code>MultiIndex</code> this is as easy as adding another column to the <code>DataFrame</code>:</p>

<pre><code class="language-python">pop_df = pd.DataFrame({'total': pop,
                       'under18': [9267089, 9284094,
                                   4687374, 4318033,
                                   5906301, 6879014]})
pop_df
</code></pre>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>total</th>
      <th>under18</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">California</th>
      <th>2000</th>
      <td>33871648</td>
      <td>9267089</td>
    </tr>
    <tr>
      <th>2010</th>
      <td>37253956</td>
      <td>9284094</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">New York</th>
      <th>2000</th>
      <td>18976457</td>
      <td>4687374</td>
    </tr>
    <tr>
      <th>2010</th>
      <td>19378102</td>
      <td>4318033</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Texas</th>
      <th>2000</th>
      <td>20851820</td>
      <td>5906301</td>
    </tr>
    <tr>
      <th>2010</th>
      <td>25145561</td>
      <td>6879014</td>
    </tr>
  </tbody>
</table>
</div>

<p>In addition, all the ufuncs and other functionality discussed in <a href="03.03-Operations-in-Pandas.ipynb" target="_blank">Operating on Data in Pandas</a> work with hierarchical indices as well.
Here we compute the fraction of people under 18 by year, given the above data:</p>

<pre><code class="language-python">f_u18 = pop_df['under18'] / pop_df['total']
f_u18.unstack()
</code></pre>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>2000</th>
      <th>2010</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>California</th>
      <td>0.273594</td>
      <td>0.249211</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>0.247010</td>
      <td>0.222831</td>
    </tr>
    <tr>
      <th>Texas</th>
      <td>0.283251</td>
      <td>0.273568</td>
    </tr>
  </tbody>
</table>
</div>

<p>This allows us to easily and quickly manipulate and explore even high-dimensional data.</p>

<h2 id="methods-of-multiindex-creation">Methods of MultiIndex Creation</h2>

<p>The most straightforward way to construct a multiply indexed <code>Series</code> or <code>DataFrame</code> is to simply pass a list of two or more index arrays to the constructor. For example:</p>

<pre><code class="language-python">df = pd.DataFrame(np.random.rand(4, 2),
                  index=[['a', 'a', 'b', 'b'], [1, 2, 1, 2]],
                  columns=['data1', 'data2'])
df
</code></pre>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>data1</th>
      <th>data2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">a</th>
      <th>1</th>
      <td>0.796230</td>
      <td>0.068256</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.426336</td>
      <td>0.132107</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>1</th>
      <td>0.143173</td>
      <td>0.353800</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.768689</td>
      <td>0.646376</td>
    </tr>
  </tbody>
</table>
</div>

<p>The work of creating the <code>MultiIndex</code> is done in the background.</p>

<p>Similarly, if you pass a dictionary with appropriate tuples as keys, Pandas will automatically recognize this and use a <code>MultiIndex</code> by default:</p>

<pre><code class="language-python">data = {('California', 2000): 33871648,
        ('California', 2010): 37253956,
        ('Texas', 2000): 20851820,
        ('Texas', 2010): 25145561,
        ('New York', 2000): 18976457,
        ('New York', 2010): 19378102}
pd.Series(data)
</code></pre>

<pre><code>California  2000    33871648
            2010    37253956
Texas       2000    20851820
            2010    25145561
New York    2000    18976457
            2010    19378102
dtype: int64
</code></pre>

<p>Nevertheless, it is sometimes useful to explicitly create a <code>MultiIndex</code>; we&rsquo;ll see a couple of these methods here.</p>

<h3 id="explicit-multiindex-constructors">Explicit MultiIndex constructors</h3>

<p>For more flexibility in how the index is constructed, you can instead use the class method constructors available in the <code>pd.MultiIndex</code>.
For example, as we did before, you can construct the <code>MultiIndex</code> from a simple list of arrays giving the index values within each level:</p>

<pre><code class="language-python">pd.MultiIndex.from_arrays([['a', 'a', 'b', 'b'], [1, 2, 1, 2]])
</code></pre>

<pre><code>MultiIndex(levels=[['a', 'b'], [1, 2]],
           codes=[[0, 0, 1, 1], [0, 1, 0, 1]])
</code></pre>

<p>You can construct it from a list of tuples giving the multiple index values of each point:</p>

<pre><code class="language-python">pd.MultiIndex.from_tuples([('a', 1), ('a', 2), ('b', 1), ('b', 2)])
</code></pre>

<pre><code>MultiIndex(levels=[['a', 'b'], [1, 2]],
           codes=[[0, 0, 1, 1], [0, 1, 0, 1]])
</code></pre>

<p>You can even construct it from a Cartesian product of single indices:</p>

<pre><code class="language-python">pd.MultiIndex.from_product([['a', 'b'], [1, 2]])
</code></pre>

<pre><code>MultiIndex(levels=[['a', 'b'], [1, 2]],
           codes=[[0, 0, 1, 1], [0, 1, 0, 1]])
</code></pre>

<p>Similarly, you can construct the <code>MultiIndex</code> directly using its internal encoding by passing <code>levels</code> (a list of lists containing available index values for each level) and <code>labels</code> (a list of lists that reference these labels):</p>

<pre><code class="language-python">pd.MultiIndex(levels=[['a', 'b'], [1, 2]],
              labels=[[0, 0, 1, 1], [0, 1, 0, 1]])
</code></pre>

<pre><code>D:\Anaconda\lib\site-packages\ipykernel_launcher.py:2: FutureWarning: the 'labels' keyword is deprecated, use 'codes' instead






MultiIndex(levels=[['a', 'b'], [1, 2]],
           codes=[[0, 0, 1, 1], [0, 1, 0, 1]])
</code></pre>

<p>Any of these objects can be passed as the <code>index</code> argument when creating a <code>Series</code> or <code>Dataframe</code>, or be passed to the <code>reindex</code> method of an existing <code>Series</code> or <code>DataFrame</code>.</p>

<h3 id="multiindex-level-names">MultiIndex level names</h3>

<p>Sometimes it is convenient to name the levels of the <code>MultiIndex</code>.
This can be accomplished by passing the <code>names</code> argument to any of the above <code>MultiIndex</code> constructors, or by setting the <code>names</code> attribute of the index after the fact:</p>

<pre><code class="language-python">pop.index.names = ['state', 'year']
pop
</code></pre>

<pre><code>state       year
California  2000    33871648
            2010    37253956
New York    2000    18976457
            2010    19378102
Texas       2000    20851820
            2010    25145561
dtype: int64
</code></pre>

<p>With more involved datasets, this can be a useful way to keep track of the meaning of various index values.</p>

<h3 id="multiindex-for-columns">MultiIndex for columns</h3>

<p>In a <code>DataFrame</code>, the rows and columns are completely symmetric, and just as the rows can have multiple levels of indices, the columns can have multiple levels as well.
Consider the following, which is a mock-up of some (somewhat realistic) medical data:</p>

<pre><code class="language-python"># hierarchical indices and columns
index = pd.MultiIndex.from_product([[2013, 2014], [1, 2]],
                                   names=['year', 'visit'])
columns = pd.MultiIndex.from_product([['Bob', 'Guido', 'Sue'], ['HR', 'Temp']],
                                     names=['subject', 'type'])

# mock some data
data = np.round(np.random.randn(4, 6), 1)
data[:, ::2] *= 10
data += 37

# create the DataFrame
health_data = pd.DataFrame(data, index=index, columns=columns)
health_data
</code></pre>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>subject</th>
      <th colspan="2" halign="left">Bob</th>
      <th colspan="2" halign="left">Guido</th>
      <th colspan="2" halign="left">Sue</th>
    </tr>
    <tr>
      <th></th>
      <th>type</th>
      <th>HR</th>
      <th>Temp</th>
      <th>HR</th>
      <th>Temp</th>
      <th>HR</th>
      <th>Temp</th>
    </tr>
    <tr>
      <th>year</th>
      <th>visit</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">2013</th>
      <th>1</th>
      <td>37.0</td>
      <td>36.7</td>
      <td>37.0</td>
      <td>36.5</td>
      <td>37.0</td>
      <td>37.5</td>
    </tr>
    <tr>
      <th>2</th>
      <td>32.0</td>
      <td>36.8</td>
      <td>50.0</td>
      <td>36.3</td>
      <td>43.0</td>
      <td>37.1</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">2014</th>
      <th>1</th>
      <td>27.0</td>
      <td>36.5</td>
      <td>38.0</td>
      <td>37.4</td>
      <td>30.0</td>
      <td>35.3</td>
    </tr>
    <tr>
      <th>2</th>
      <td>28.0</td>
      <td>38.4</td>
      <td>32.0</td>
      <td>36.9</td>
      <td>33.0</td>
      <td>38.8</td>
    </tr>
  </tbody>
</table>
</div>

<p>Here we see where the multi-indexing for both rows and columns can come in <em>very</em> handy.
This is fundamentally four-dimensional data, where the dimensions are the subject, the measurement type, the year, and the visit number.
With this in place we can, for example, index the top-level column by the person&rsquo;s name and get a full <code>DataFrame</code> containing just that person&rsquo;s information:</p>

<pre><code class="language-python">health_data['Guido']
</code></pre>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>type</th>
      <th>HR</th>
      <th>Temp</th>
    </tr>
    <tr>
      <th>year</th>
      <th>visit</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">2013</th>
      <th>1</th>
      <td>37.0</td>
      <td>36.5</td>
    </tr>
    <tr>
      <th>2</th>
      <td>50.0</td>
      <td>36.3</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">2014</th>
      <th>1</th>
      <td>38.0</td>
      <td>37.4</td>
    </tr>
    <tr>
      <th>2</th>
      <td>32.0</td>
      <td>36.9</td>
    </tr>
  </tbody>
</table>
</div>

<p>For complicated records containing multiple labeled measurements across multiple times for many subjects (people, countries, cities, etc.) use of hierarchical rows and columns can be extremely convenient!</p>

<h2 id="indexing-and-slicing-a-multiindex">Indexing and Slicing a MultiIndex</h2>

<p>Indexing and slicing on a <code>MultiIndex</code> is designed to be intuitive, and it helps if you think about the indices as added dimensions.
We&rsquo;ll first look at indexing multiply indexed <code>Series</code>, and then multiply-indexed <code>DataFrame</code>s.</p>

<h3 id="multiply-indexed-series">Multiply indexed Series</h3>

<p>Consider the multiply indexed <code>Series</code> of state populations we saw earlier:</p>

<pre><code class="language-python">pop
</code></pre>

<pre><code>state       year
California  2000    33871648
            2010    37253956
New York    2000    18976457
            2010    19378102
Texas       2000    20851820
            2010    25145561
dtype: int64
</code></pre>

<p>We can access single elements by indexing with multiple terms:</p>

<pre><code class="language-python">pop['California', 2000]
</code></pre>

<pre><code>33871648
</code></pre>

<p>The <code>MultiIndex</code> also supports <em>partial indexing</em>, or indexing just one of the levels in the index.
The result is another <code>Series</code>, with the lower-level indices maintained:</p>

<pre><code class="language-python">pop['California']
</code></pre>

<pre><code>year
2000    33871648
2010    37253956
dtype: int64
</code></pre>

<p>Partial slicing is available as well, as long as the <code>MultiIndex</code> is sorted (see discussion in <a href="#Sorted-and-unsorted-indices">Sorted and Unsorted Indices</a>):</p>

<pre><code class="language-python">pop.loc['California':'New York']
</code></pre>

<pre><code>state       year
California  2000    33871648
            2010    37253956
New York    2000    18976457
            2010    19378102
dtype: int64
</code></pre>

<p>With sorted indices, partial indexing can be performed on lower levels by passing an empty slice in the first index:</p>

<pre><code class="language-python">pop[:, 2000]
</code></pre>

<pre><code>state
California    33871648
New York      18976457
Texas         20851820
dtype: int64
</code></pre>

<p>Other types of indexing and selection (discussed in <a href="03.02-Data-Indexing-and-Selection.ipynb" target="_blank">Data Indexing and Selection</a>) work as well; for example, selection based on Boolean masks:</p>

<pre><code class="language-python">pop[pop &gt; 22000000]
</code></pre>

<pre><code>state       year
California  2000    33871648
            2010    37253956
Texas       2010    25145561
dtype: int64
</code></pre>

<p>Selection based on fancy indexing also works:</p>

<pre><code class="language-python">pop[['California', 'Texas']]
</code></pre>

<pre><code>state       year
California  2000    33871648
            2010    37253956
Texas       2000    20851820
            2010    25145561
dtype: int64
</code></pre>

<h3 id="multiply-indexed-dataframes">Multiply indexed DataFrames</h3>

<p>A multiply indexed <code>DataFrame</code> behaves in a similar manner.
Consider our toy medical <code>DataFrame</code> from before:</p>

<pre><code class="language-python">health_data
</code></pre>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>subject</th>
      <th colspan="2" halign="left">Bob</th>
      <th colspan="2" halign="left">Guido</th>
      <th colspan="2" halign="left">Sue</th>
    </tr>
    <tr>
      <th></th>
      <th>type</th>
      <th>HR</th>
      <th>Temp</th>
      <th>HR</th>
      <th>Temp</th>
      <th>HR</th>
      <th>Temp</th>
    </tr>
    <tr>
      <th>year</th>
      <th>visit</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">2013</th>
      <th>1</th>
      <td>37.0</td>
      <td>36.7</td>
      <td>37.0</td>
      <td>36.5</td>
      <td>37.0</td>
      <td>37.5</td>
    </tr>
    <tr>
      <th>2</th>
      <td>32.0</td>
      <td>36.8</td>
      <td>50.0</td>
      <td>36.3</td>
      <td>43.0</td>
      <td>37.1</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">2014</th>
      <th>1</th>
      <td>27.0</td>
      <td>36.5</td>
      <td>38.0</td>
      <td>37.4</td>
      <td>30.0</td>
      <td>35.3</td>
    </tr>
    <tr>
      <th>2</th>
      <td>28.0</td>
      <td>38.4</td>
      <td>32.0</td>
      <td>36.9</td>
      <td>33.0</td>
      <td>38.8</td>
    </tr>
  </tbody>
</table>
</div>

<p>Remember that columns are primary in a <code>DataFrame</code>, and the syntax used for multiply indexed <code>Series</code> applies to the columns.
For example, we can recover Guido&rsquo;s heart rate data with a simple operation:</p>

<pre><code class="language-python">health_data['Guido', 'HR']
</code></pre>

<pre><code>year  visit
2013  1        37.0
      2        50.0
2014  1        38.0
      2        32.0
Name: (Guido, HR), dtype: float64
</code></pre>

<p>Also, as with the single-index case, we can use the <code>loc</code>, <code>iloc</code>, and <code>ix</code> indexers introduced in <a href="03.02-Data-Indexing-and-Selection.ipynb" target="_blank">Data Indexing and Selection</a>. For example:</p>

<pre><code class="language-python">health_data.iloc[:2, :2]
</code></pre>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>subject</th>
      <th colspan="2" halign="left">Bob</th>
    </tr>
    <tr>
      <th></th>
      <th>type</th>
      <th>HR</th>
      <th>Temp</th>
    </tr>
    <tr>
      <th>year</th>
      <th>visit</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">2013</th>
      <th>1</th>
      <td>37.0</td>
      <td>36.7</td>
    </tr>
    <tr>
      <th>2</th>
      <td>32.0</td>
      <td>36.8</td>
    </tr>
  </tbody>
</table>
</div>

<p>These indexers provide an array-like view of the underlying two-dimensional data, but each individual index in <code>loc</code> or <code>iloc</code> can be passed a tuple of multiple indices. For example:</p>

<pre><code class="language-python">health_data.loc[:, ('Bob', 'HR')]
</code></pre>

<pre><code>year  visit
2013  1        37.0
      2        32.0
2014  1        27.0
      2        28.0
Name: (Bob, HR), dtype: float64
</code></pre>

<p>Working with slices within these index tuples is not especially convenient; trying to create a slice within a tuple will lead to a syntax error:</p>

<pre><code class="language-python">health_data.loc[(:, 1), (:, 'HR')]
</code></pre>

<pre><code>  File &quot;&lt;ipython-input-33-fb34fa30ac09&gt;&quot;, line 1
    health_data.loc[(:, 1), (:, 'HR')]
                     ^
SyntaxError: invalid syntax
</code></pre>

<p>You could get around this by building the desired slice explicitly using Python&rsquo;s built-in <code>slice()</code> function, but a better way in this context is to use an <code>IndexSlice</code> object, which Pandas provides for precisely this situation.
For example:</p>

<pre><code class="language-python">idx = pd.IndexSlice
health_data.loc[idx[:, 1], idx[:, 'HR']]
</code></pre>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>subject</th>
      <th>Bob</th>
      <th>Guido</th>
      <th>Sue</th>
    </tr>
    <tr>
      <th></th>
      <th>type</th>
      <th>HR</th>
      <th>HR</th>
      <th>HR</th>
    </tr>
    <tr>
      <th>year</th>
      <th>visit</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013</th>
      <th>1</th>
      <td>37.0</td>
      <td>37.0</td>
      <td>37.0</td>
    </tr>
    <tr>
      <th>2014</th>
      <th>1</th>
      <td>27.0</td>
      <td>38.0</td>
      <td>30.0</td>
    </tr>
  </tbody>
</table>
</div>

<p>There are so many ways to interact with data in multiply indexed <code>Series</code> and <code>DataFrame</code>s, and as with many tools in this book the best way to become familiar with them is to try them out!</p>

<h2 id="rearranging-multi-indices">Rearranging Multi-Indices</h2>

<p>One of the keys to working with multiply indexed data is knowing how to effectively transform the data.
There are a number of operations that will preserve all the information in the dataset, but rearrange it for the purposes of various computations.
We saw a brief example of this in the <code>stack()</code> and <code>unstack()</code> methods, but there are many more ways to finely control the rearrangement of data between hierarchical indices and columns, and we&rsquo;ll explore them here.</p>

<h3 id="sorted-and-unsorted-indices">Sorted and unsorted indices</h3>

<p>Earlier, we briefly mentioned a caveat, but we should emphasize it more here.
<em>Many of the <code>MultiIndex</code> slicing operations will fail if the index is not sorted.</em>
Let&rsquo;s take a look at this here.</p>

<p>We&rsquo;ll start by creating some simple multiply indexed data where the indices are <em>not lexographically sorted</em>:</p>

<pre><code class="language-python">index = pd.MultiIndex.from_product([['a', 'c', 'b'], [1, 2]])
data = pd.Series(np.random.rand(6), index=index)
data.index.names = ['char', 'int']
data
</code></pre>

<pre><code>char  int
a     1      0.748770
      2      0.813412
c     1      0.551106
      2      0.423799
b     1      0.450351
      2      0.241441
dtype: float64
</code></pre>

<p>If we try to take a partial slice of this index, it will result in an error:</p>

<pre><code class="language-python">try:
    data['a':'b']
except KeyError as e:
    print(type(e))
    print(e)
</code></pre>

<pre><code>&lt;class 'pandas.errors.UnsortedIndexError'&gt;
'Key length (1) was greater than MultiIndex lexsort depth (0)'
</code></pre>

<p>Although it is not entirely clear from the error message, this is the result of the MultiIndex not being sorted.
For various reasons, partial slices and other similar operations require the levels in the <code>MultiIndex</code> to be in sorted (i.e., lexographical) order.
Pandas provides a number of convenience routines to perform this type of sorting; examples are the <code>sort_index()</code> and <code>sortlevel()</code> methods of the <code>DataFrame</code>.
We&rsquo;ll use the simplest, <code>sort_index()</code>, here:</p>

<pre><code class="language-python">data = data.sort_index()
data
</code></pre>

<pre><code>char  int
a     1      0.748770
      2      0.813412
b     1      0.450351
      2      0.241441
c     1      0.551106
      2      0.423799
dtype: float64
</code></pre>

<p>With the index sorted in this way, partial slicing will work as expected:</p>

<pre><code class="language-python">data['a':'b']
</code></pre>

<pre><code>char  int
a     1      0.748770
      2      0.813412
b     1      0.450351
      2      0.241441
dtype: float64
</code></pre>

<h3 id="stacking-and-unstacking-indices">Stacking and unstacking indices</h3>

<p>As we saw briefly before, it is possible to convert a dataset from a stacked multi-index to a simple two-dimensional representation, optionally specifying the level to use:</p>

<pre><code class="language-python">pop.unstack(level=0)
</code></pre>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>state</th>
      <th>California</th>
      <th>New York</th>
      <th>Texas</th>
    </tr>
    <tr>
      <th>year</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2000</th>
      <td>33871648</td>
      <td>18976457</td>
      <td>20851820</td>
    </tr>
    <tr>
      <th>2010</th>
      <td>37253956</td>
      <td>19378102</td>
      <td>25145561</td>
    </tr>
  </tbody>
</table>
</div>

<pre><code class="language-python">pop.unstack(level=1)
</code></pre>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>year</th>
      <th>2000</th>
      <th>2010</th>
    </tr>
    <tr>
      <th>state</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>California</th>
      <td>33871648</td>
      <td>37253956</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>18976457</td>
      <td>19378102</td>
    </tr>
    <tr>
      <th>Texas</th>
      <td>20851820</td>
      <td>25145561</td>
    </tr>
  </tbody>
</table>
</div>

<p>The opposite of <code>unstack()</code> is <code>stack()</code>, which here can be used to recover the original series:</p>

<pre><code class="language-python">pop.unstack().stack()
</code></pre>

<pre><code>state       year
California  2000    33871648
            2010    37253956
New York    2000    18976457
            2010    19378102
Texas       2000    20851820
            2010    25145561
dtype: int64
</code></pre>

<h3 id="index-setting-and-resetting">Index setting and resetting</h3>

<p>Another way to rearrange hierarchical data is to turn the index labels into columns; this can be accomplished with the <code>reset_index</code> method.
Calling this on the population dictionary will result in a <code>DataFrame</code> with a <em>state</em> and <em>year</em> column holding the information that was formerly in the index.
For clarity, we can optionally specify the name of the data for the column representation:</p>

<pre><code class="language-python">pop_flat = pop.reset_index(name='population')
pop_flat
</code></pre>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>state</th>
      <th>year</th>
      <th>population</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>California</td>
      <td>2000</td>
      <td>33871648</td>
    </tr>
    <tr>
      <th>1</th>
      <td>California</td>
      <td>2010</td>
      <td>37253956</td>
    </tr>
    <tr>
      <th>2</th>
      <td>New York</td>
      <td>2000</td>
      <td>18976457</td>
    </tr>
    <tr>
      <th>3</th>
      <td>New York</td>
      <td>2010</td>
      <td>19378102</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Texas</td>
      <td>2000</td>
      <td>20851820</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Texas</td>
      <td>2010</td>
      <td>25145561</td>
    </tr>
  </tbody>
</table>
</div>

<p>Often when working with data in the real world, the raw input data looks like this and it&rsquo;s useful to build a <code>MultiIndex</code> from the column values.
This can be done with the <code>set_index</code> method of the <code>DataFrame</code>, which returns a multiply indexed <code>DataFrame</code>:</p>

<pre><code class="language-python">pop_flat.set_index(['state', 'year'])
</code></pre>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>population</th>
    </tr>
    <tr>
      <th>state</th>
      <th>year</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">California</th>
      <th>2000</th>
      <td>33871648</td>
    </tr>
    <tr>
      <th>2010</th>
      <td>37253956</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">New York</th>
      <th>2000</th>
      <td>18976457</td>
    </tr>
    <tr>
      <th>2010</th>
      <td>19378102</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Texas</th>
      <th>2000</th>
      <td>20851820</td>
    </tr>
    <tr>
      <th>2010</th>
      <td>25145561</td>
    </tr>
  </tbody>
</table>
</div>

<p>In practice, I find this type of reindexing to be one of the more useful patterns when encountering real-world datasets.</p>

<h2 id="data-aggregations-on-multi-indices">Data Aggregations on Multi-Indices</h2>

<p>We&rsquo;ve previously seen that Pandas has built-in data aggregation methods, such as <code>mean()</code>, <code>sum()</code>, and <code>max()</code>.
For hierarchically indexed data, these can be passed a <code>level</code> parameter that controls which subset of the data the aggregate is computed on.</p>

<p>For example, let&rsquo;s return to our health data:</p>

<pre><code class="language-python">health_data
</code></pre>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>subject</th>
      <th colspan="2" halign="left">Bob</th>
      <th colspan="2" halign="left">Guido</th>
      <th colspan="2" halign="left">Sue</th>
    </tr>
    <tr>
      <th></th>
      <th>type</th>
      <th>HR</th>
      <th>Temp</th>
      <th>HR</th>
      <th>Temp</th>
      <th>HR</th>
      <th>Temp</th>
    </tr>
    <tr>
      <th>year</th>
      <th>visit</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">2013</th>
      <th>1</th>
      <td>37.0</td>
      <td>36.7</td>
      <td>37.0</td>
      <td>36.5</td>
      <td>37.0</td>
      <td>37.5</td>
    </tr>
    <tr>
      <th>2</th>
      <td>32.0</td>
      <td>36.8</td>
      <td>50.0</td>
      <td>36.3</td>
      <td>43.0</td>
      <td>37.1</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">2014</th>
      <th>1</th>
      <td>27.0</td>
      <td>36.5</td>
      <td>38.0</td>
      <td>37.4</td>
      <td>30.0</td>
      <td>35.3</td>
    </tr>
    <tr>
      <th>2</th>
      <td>28.0</td>
      <td>38.4</td>
      <td>32.0</td>
      <td>36.9</td>
      <td>33.0</td>
      <td>38.8</td>
    </tr>
  </tbody>
</table>
</div>

<p>Perhaps we&rsquo;d like to average-out the measurements in the two visits each year. We can do this by naming the index level we&rsquo;d like to explore, in this case the year:</p>

<pre><code class="language-python">data_mean = health_data.mean(level='year')
data_mean
</code></pre>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th>subject</th>
      <th colspan="2" halign="left">Bob</th>
      <th colspan="2" halign="left">Guido</th>
      <th colspan="2" halign="left">Sue</th>
    </tr>
    <tr>
      <th>type</th>
      <th>HR</th>
      <th>Temp</th>
      <th>HR</th>
      <th>Temp</th>
      <th>HR</th>
      <th>Temp</th>
    </tr>
    <tr>
      <th>year</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013</th>
      <td>34.5</td>
      <td>36.75</td>
      <td>43.5</td>
      <td>36.40</td>
      <td>40.0</td>
      <td>37.30</td>
    </tr>
    <tr>
      <th>2014</th>
      <td>27.5</td>
      <td>37.45</td>
      <td>35.0</td>
      <td>37.15</td>
      <td>31.5</td>
      <td>37.05</td>
    </tr>
  </tbody>
</table>
</div>

<p>By further making use of the <code>axis</code> keyword, we can take the mean among levels on the columns as well:</p>

<pre><code class="language-python">data_mean.mean(axis=1, level='type')
</code></pre>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>type</th>
      <th>HR</th>
      <th>Temp</th>
    </tr>
    <tr>
      <th>year</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2013</th>
      <td>39.333333</td>
      <td>36.816667</td>
    </tr>
    <tr>
      <th>2014</th>
      <td>31.333333</td>
      <td>37.216667</td>
    </tr>
  </tbody>
</table>
</div>

<p>Thus in two lines, we&rsquo;ve been able to find the average heart rate and temperature measured among all subjects in all visits each year.
This syntax is actually a short cut to the <code>GroupBy</code> functionality, which we will discuss in <a href="03.08-Aggregation-and-Grouping.ipynb" target="_blank">Aggregation and Grouping</a>.
While this is a toy example, many real-world datasets have similar hierarchical structure.</p>

<h2 id="aside-panel-data">Aside: Panel Data</h2>

<p>Pandas has a few other fundamental data structures that we have not yet discussed, namely the <code>pd.Panel</code> and <code>pd.Panel4D</code> objects.
These can be thought of, respectively, as three-dimensional and four-dimensional generalizations of the (one-dimensional) <code>Series</code> and (two-dimensional) <code>DataFrame</code> structures.
Once you are familiar with indexing and manipulation of data in a <code>Series</code> and <code>DataFrame</code>, <code>Panel</code> and <code>Panel4D</code> are relatively straightforward to use.
In particular, the <code>ix</code>, <code>loc</code>, and <code>iloc</code> indexers discussed in <a href="03.02-Data-Indexing-and-Selection.ipynb" target="_blank">Data Indexing and Selection</a> extend readily to these higher-dimensional structures.</p>

<p>We won&rsquo;t cover these panel structures further in this text, as I&rsquo;ve found in the majority of cases that multi-indexing is a more useful and conceptually simpler representation for higher-dimensional data.
Additionally, panel data is fundamentally a dense data representation, while multi-indexing is fundamentally a sparse data representation.
As the number of dimensions increases, the dense representation can become very inefficient for the majority of real-world datasets.
For the occasional specialized application, however, these structures can be useful.
If you&rsquo;d like to read more about the <code>Panel</code> and <code>Panel4D</code> structures, see the references listed in <a href="03.13-Further-Resources.ipynb" target="_blank">Further Resources</a>.</p>

          </div>

          



          
          <div class="article-widget">
            
<div class="post-nav">
  
  
  
  <div class="post-nav-item box ">
    <div class="meta-nav meta-prev">Previous <br>
    <a href="/coding/tutorials/data-science-handbook/3.pandas/03.04-missing-values/" rel="next">Handling Missing Data</a></div>
  </div>
  
  
  
  <div class="post-nav-item box">
    <div class="meta-nav meta-next" >Next <br>
    <a href="/coding/tutorials/data-science-handbook/3.pandas/03.06-concat-and-append/" rel="prev">Concat and Append</a></div>
  </div>
  
  <br>
  <br>
</div>

          </div>
          
        </div>

        <div class="body-footer">
          Last updated on Jun 19, 2020
        </div>

      </article>

      <footer class="site-footer">

  <div class="container">
    <div class="row">
      <div class="col-md-6">
        
        <p>
          
          Powered by
          <a href="https://themefisher.com" target="_blank" rel="noopener">themefisher</a> for
          <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.
        </p>
      </div>
      <div class="col-md-6">
        <ul class="list-inline network-icon text-right">
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="list-inline-item">
            <a href="https://twitter.com/Twitter" target="_blank" rel="noopener" title="DM Me"><i class="fab fa-twitter" aria-hidden="true"></i></a>
          </li>
          
          
          
          
          
          
          
          
          
          
          <li class="list-inline-item">
            <a href="skype:echo123?call"  title="Skype Me"><i class="fab fa-skype" aria-hidden="true"></i></a>
          </li>
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="list-inline-item">
            <a href="https://keybase.io/" target="_blank" rel="noopener" title="Chat on Keybase"><i class="fab fa-keybase" aria-hidden="true"></i></a>
          </li>
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="list-inline-item">
            <a href="https://discourse.gohugo.io" target="_blank" rel="noopener" title="Discuss on Forum"><i class="fas fa-comments" aria-hidden="true"></i></a>
          </li>
          
        </ul>
      </div>
    </div>
  </div>
</footer>

    </main>
  </div>
</div>


      

    
    
    
    <script src="/coding/js/mathjax-config.js"></script>
    

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" integrity="sha256-X5PoE3KU5l+JcX+w09p/wHl9AzK333C4hJ2I9S5mD4M=" crossorigin="anonymous"></script>

      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js" integrity="sha256-aYTdUrn6Ow1DDgh5JTc3aDGnnju48y/1c8s1dgkYPQ8=" crossorigin="anonymous"></script>
        
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/languages/python.min.js"></script>
        
      

      
      
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS_CHTML-full" integrity="sha256-GhM+5JHb6QUzOQPXSJLEWP7R73CbkisjzK5Eyij4U9w=" crossorigin="anonymous" async></script>
      
    

    
    

    
    
    

    
    
    <script>hljs.initHighlightingOnLoad();</script>
    

    
    
    <script>
      const search_index_filename = "/coding/index.json";
      const i18n = {
        'placeholder': "Search...",
        'results': "results found",
        'no_results': "No results found"
      };
      const content_type = {
        'post': "Posts",
        'project': "Projects",
        'publication' : "Publications",
        'talk' : "Talks"
        };
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.1/anchor.min.js" integrity="sha256-pB/deHc9CGfFpJRjC43imB29Rse8tak+5eXqntO94ck=" crossorigin="anonymous"></script>
    <script>
      anchors.add();
    </script>
    

    
    
    <script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
    

    
    

    
    
    
    
    
    
    
    
    
      
    
    
    
    
    <script src="/coding/js/academia.min.e4fc229c2f28284fc2dfa5b66a52b765.js"></script>

    






  

  
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cite</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copy
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

</body>
</html>
